<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Título actualizado -->
    <title>Simulador Tutor IA - V17 (Choice 2.3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide-react@latest/dist/umd/lucide.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
    </script>
    
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f6; }
        .loader {
            border: 4px solid #f3f3ff; border-top: 4px solid #3498db; border-radius: 50%;
            width: 32px; height: 32px; animation: spin 1s linear infinite; margin: 20px auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* Tabs */
        .tab-button { transition: all 0.2s ease-in-out; border-bottom-width: 3px; border-color: transparent; }
        .tab-button.active { border-color: #2563eb; color: #1d4ed8; }
        .tab-panel { display: none; }
        .tab-panel.active { display: block; }
        
        /* Cards & Interactive Elements */
        .mode-card {
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            padding: 32px; border: 2px solid #e5e7eb; border-radius: 16px; transition: all 0.2s;
            cursor: pointer; text-align: center; background-color: #f9fafb;
        }
        .mode-card:hover {
            border-color: #2563eb; background-color: white;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1); transform: translateY(-4px);
        }
        
        /* Progress Bars */
        .progress-bar-container { width: 100%; background-color: #e5e7eb; border-radius: 9999px; height: 12px; overflow: hidden; }
        .progress-bar-fill { height: 100%; background-color: #2563eb; border-radius: 9999px; transition: width 0.5s ease-in-out; }

        /* Choice Mode Styles */
        .mcq-option {
            display: flex; align-items: center; padding: 12px 16px; margin-bottom: 8px;
            border: 2px solid #e5e7eb; border-radius: 8px; cursor: pointer; transition: all 0.2s;
        }
        .mcq-option:hover { background-color: #f3f4f6; }
        .mcq-option.selected { border-color: #2563eb; background-color: #eff6ff; }
        .mcq-option.correct { border-color: #10b981; background-color: #d1fae5; }
        .mcq-option.incorrect { border-color: #ef4444; background-color: #fee2e2; }
        
        .hint-box {
            background-color: #fffbeb; border-left: 4px solid #f59e0b; color: #92400e;
            padding: 12px; margin-top: 12px; font-size: 0.9rem; display: none; border-radius: 4px;
        }
        
        .flashcard-feedback {
            display: none; font-size: 0.8rem; font-weight: 600; color: #057a55;
            background-color: #d1fae5; padding: 6px 10px; border-radius: 6px;
            margin-top: 10px; text-align: center;
        }
        
        /* NUEVO: Estilos para Modo Práctica y Acordeón de Justificación */
        .practice-mode-menu {
            display: flex; flex-direction: column; gap: 12px; padding: 16px;
            background-color: #f9fafb; border-radius: 12px; border: 1px solid #e5e7eb;
        }
        .practice-mode-btn {
            padding: 12px; font-size: 1rem; font-weight: 600; border-radius: 8px;
            border: 2px solid #d1d5db; transition: all 0.2s;
            display: flex; flex-direction: column; align-items: flex-start;
        }
        .practice-mode-btn:hover { background-color: #eff6ff; border-color: #2563eb; }
        .practice-mode-btn span { font-size: 0.8rem; font-weight: 400; color: #4b5563; }
        
        .justification-accordion-btn {
            width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center;
            padding: 8px 12px; background-color: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px;
            font-weight: 500; font-size: 0.9rem; color: #1f2937; margin-top: 12px;
        }
        .justification-accordion-btn:hover { background-color: #f3f4f6; }
        .justification-accordion-btn[aria-expanded="true"] .lucide-chevron-down { transform: rotate(180deg); }
        .justification-content {
             display: none; padding: 12px; border-left: 2px solid #e5e7eb; margin-top: 4px;
             font-size: 0.9rem; background-color: #fdfdfd;
        }
        .justification-content.open { display: block; }
        /* FIN NUEVO */


        /* General Reused Styles */
        .qa-card { background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 16px; margin-bottom: 12px; position: relative; }
        .qa-card img { max-width: 100%; height: auto; border-radius: 4px; margin-top: 8px; }
        .delete-qa-btn { position: absolute; top: 12px; right: 12px; background: #fee2e2; color: #dc2626; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 5;}
        .edit-qa-btn { position: absolute; top: 12px; right: 48px; background: #dbeafe; color: #2563eb; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; z-index: 5;}
        
        /* Accordion Styles */
        .accordion-btn {
            width: 100%; text-align: left; display: flex; justify-content: space-between; align-items: center;
            padding: 16px; background-color: #f9fafb; border: 1px solid #e5e7eb; border-radius: 8px;
            font-weight: 600; font-size: 1.1rem; color: #1f2937; margin-bottom: 4px;
        }
        .accordion-btn:hover { background-color: #f3f4f6; }
        .accordion-content { display: none; padding-left: 16px; border-left: 2px solid #e5e7eb; margin-bottom: 12px; }
        .open { display: block; }
        .accordion-btn .toggle-icon { transition: transform 0.2s; }
        .accordion-btn[aria-expanded="true"] .toggle-icon { transform: rotate(180deg); }
        /* CORRECCIÓN: Estilo para el ícono (SVG) cuando ya fue renderizado por lucide */
        .accordion-btn[aria-expanded="true"] .lucide-chevron-down { transform: rotate(180deg); }


        /* Overdue Disclaimer Style */
        .overdue-disclaimer {
            background-color: #fef2f2; /* red-50 */
            border: 1px solid #fca5a5; /* red-300 */
            border-left-width: 4px;
            border-left-color: #ef4444; /* red-500 */
            color: #b91c1c; /* red-700 */
            padding: 12px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 16px;
        }
        
        /* Botón de eliminar en Admin Temas */
        .delete-question-btn {
            background-color: #fee2e2; color: #dc2626; border-radius: 50%;
            width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;
            flex-shrink: 0; margin-left: 8px;
        }
        .delete-question-btn:hover { background-color: #fecaca; }

        /* --- INICIO: Estilos para "Modo Estudio" (Traídos de V6) --- */
        
        /* Estilos para el Navegador de Temas (Modo Estudio) */
        .syllabus-browser .unit-toggle-btn {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            color: #1f2937; /* gray-800 */
            margin-bottom: 8px;
            border-bottom-width: 1px;
        }
        .syllabus-browser .unit-topics-container {
            border-left: 2px solid #e5e7eb; /* gray-200 */
        }
        .syllabus-topic-btn {
            display: block;
            width: 100%;
            text-align: left;
            padding: 12px 16px;
            font-size: 1rem;
            font-weight: 500;
            color: #374151; /* gray-700 */
            border-radius: 8px;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .syllabus-topic-btn:hover {
            background-color: #f4f7f6; /* nuestro bg-body */
        }
        .syllabus-topic-btn:not(:last-child) {
            margin-bottom: 4px;
        }
        
        /* Estilos para la Guía de Estudio (Modo Estudio) */
        .guide-summary {
            font-size: 1.125rem; /* text-lg */
            color: #374151; /* gray-700 */
            background-color: #f9fafb; /* gray-50 */
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #2563eb; /* blue-600 */
            margin-bottom: 24px;
        }
        .subtopic-block {
            background-color: white;
            border: 1px solid #e5e7eb; /* gray-200 */
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .subtopic-header {
            padding: 16px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .subtopic-header h4 {
            font-size: 1.25rem; /* text-xl */
            font-weight: 600; /* font-semibold */
            color: #111827; /* gray-900 */
        }
        .importance-badge {
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 0.75rem; /* text-xs */
            font-weight: 700; /* font-bold */
            text-transform: uppercase;
        }
        .importance-badge-alta { background-color: #fee2e2; color: #b91c1c; } /* red */
        .importance-badge-media { background-color: #fef3c7; color: #b45309; } /* amber */
        .importance-badge-baja { background-color: #dbeafe; color: #1e40af; } /* blue */
        
        .subtopic-body {
            padding: 16px;
        }
        .ai-justification {
            font-size: 0.875rem; /* text-sm */
            color: #4b5563; /* gray-600 */
            font-style: italic;
            margin-bottom: 16px;
        }
        /* CSS para el item de pregunta */
        .question-item {
            border-top: 1px solid #f3f4f6; /* gray-100 */
            padding-top: 16px;
        }
        .question-item .question-text {
            font-weight: 600;
            color: #1f2937;
        }
        /* CSS para el loader de sub-pregunta */
        .sub-question-loader {
            display: none; /* Oculto por defecto */
        }

        .generate-more-btn {
            margin-top: 16px;
            width: 100%;
            padding: 10px;
            font-weight: 500;
            background-color: #f3f4f6; /* gray-100 */
            border-top: 1px solid #e5e7eb;
            color: #1f2937;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            cursor: pointer;
        }
        .generate-more-btn:hover {
            background-color: #e5e7eb; /* gray-200 */
        }
        .sub-question-container {
            padding: 0 16px 16px 16px; /* Padding para preguntas generadas */
        }
        /* CSS para el loader de respuesta y audio */
        .answer-loader {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 8px;
        }
        .answer-text {
            font-size: 0.9rem;
            color: #1f2937; /* gray-800 */
            margin-top: 10px;
            border-radius: 4px;
            white-space: pre-wrap; /* Mantiene saltos de línea y espacios */
            background-color: #f9fafb; /* gray-50 */
            border: 1px solid #e5e7eb;
            border-left: 4px solid #2563eb; /* blue-600 */
            padding: 10px 14px;
        }
        .audio-player-container audio {
            width: 100%;
            height: 38px;
            margin-top: 8px;
        }
        /* --- FIN: Estilos para "Modo Estudio" --- */
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Modal Sincronización -->
    <div id="sync-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center p-4 z-50" style="display: none;">
        <div class="bg-white rounded-2xl shadow-xl p-6 max-w-md w-full">
            <h3 class="text-2xl font-bold text-gray-800">Configurar Sincronización</h3>
            <p class="mt-3 text-gray-600">Para mantener tus datos, usa el mismo ID en todos tus dispositivos.</p>
            <div class="mt-6">
                <label class="block text-sm font-medium text-gray-700">Tu ID actual o nuevo:</label>
                <input type="text" id="sync-id-input" class="w-full mt-1 p-2 border border-gray-300 rounded-lg shadow-sm">
                <button id="save-sync-id" class="mt-3 w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">Usar este ID</button>
                <button id="generate-sync-id" class="mt-3 w-full px-4 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700">Generar Nuevo ID</button>
            </div>
        </div>
    </div>

    <div class="max-w-6xl mx-auto p-4 sm:p-8">
        
        <!-- Header -->
        <header class="mb-8 bg-white shadow-lg rounded-xl p-6 sm:p-8">
            <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-2">Simulador Tutor IA</h1>
            <p class="text-lg text-gray-600">Entrenamiento inteligente: Oral, Choice y Repaso Espaciado.</p>
            
            <!-- Selector de Materia -->
            <div id="subject-header" class="mt-6 border-t border-gray-200 pt-4">
                <label class="block text-base font-semibold text-gray-800 mb-2">Materia Actual:</label>
                <div class="flex flex-col sm:flex-row sm:space-x-2">
                    <select id="subject-selector" class="w-full sm:w-1/2 p-2.5 border border-gray-300 rounded-lg bg-white">
                        <option value="">-- Seleccionar --</option>
                        <option value="all">-- Ver Todas --</option>
                    </select>
                    <input type="text" id="new-subject-name" placeholder="Nueva materia..." class="mt-2 sm:mt-0 w-full sm:w-1/2 p-2.5 border border-gray-300 rounded-lg">
                    <button id="add-subject-btn" class="mt-2 sm:mt-0 px-5 py-2.5 bg-gray-800 text-white font-semibold rounded-lg hover:bg-gray-900">Crear</button>
                </div>
            </div>
            <div id="sync-id-display" class="mt-3 text-xs text-gray-500 flex items-center gap-2" style="display: none;">
                <span>ID: <span id="user-id" class="font-mono bg-gray-100 p-1 rounded">...</span></span>
                <button id="change-sync-id" class="px-2 py-0.5 bg-gray-200 text-gray-700 rounded text-xs hover:bg-gray-300">Cambiar ID</button>
            </div>
        </header>

        <!-- Navegación Tabs -->
        <div class="mb-6 overflow-x-auto">
            <nav class="flex space-x-6 border-b border-gray-300 min-w-max" aria-label="Tabs">
                <button id="tab-material-btn" class="tab-button active py-4 text-lg font-semibold text-gray-500">Material</button>
                <button id="tab-choice-btn" class="tab-button py-4 text-lg font-semibold text-gray-500">Modo Choice</button>
                <button id="tab-simulador-btn" class="tab-button py-4 text-lg font-semibold text-gray-500">Modo Oral</button>
                <button id="tab-review-btn" class="tab-button py-4 text-lg font-semibold text-gray-500">Repasar</button>
                <button id="tab-topics-btn" class="tab-button py-4 text-lg font-semibold text-gray-500">Administrar Temas</button>
                <button id="tab-roadmap-btn" class="tab-button py-4 text-lg font-semibold text-gray-500">Hoja de Ruta</button>
            </nav>
        </div>

        <div class="bg-white shadow-xl rounded-xl p-6 sm:p-8 min-h-[500px]">
            
            <!-- TAB: MATERIAL (Ahora es la pestaña activa por defecto) -->
            <div id="tab-material" class="tab-panel active space-y-6">
                <p class="text-gray-600">Carga aquí la base de conocimiento para la IA. Es fundamental para que clasifique preguntas y detecte temas.</p>
                <!-- Syllabus -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-lg font-semibold text-gray-800">Plan de Estudio / Temario</label>
                        <button class="upload-pdf-btn px-3 py-1 bg-blue-100 text-blue-700 text-sm rounded hover:bg-blue-200" data-target="syllabus">Subir PDF</button>
                    </div>
                    <textarea id="syllabus" rows="6" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="Copia aquí el programa de la materia..."></textarea>
                </div>
                <!-- Theory -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-lg font-semibold text-gray-800">Teoría / Apuntes / Libros</label>
                        <button class="upload-pdf-btn px-3 py-1 bg-blue-100 text-blue-700 text-sm rounded hover:bg-blue-200" data-target="theory">Subir PDF</button>
                    </div>
                    <textarea id="theory" rows="8" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="Copia aquí apuntes clave o resúmenes..."></textarea>
                </div>
                <!-- Experiences -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-lg font-semibold text-gray-800">Experiencias Orales (Opcional)</label>
                        <button class="upload-pdf-btn px-3 py-1 bg-blue-100 text-blue-700 text-sm rounded hover:bg-blue-200" data-target="experiences">Subir PDF</button>
                    </div>
                    <textarea id="experiences" rows="4" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500" placeholder="Preguntas que hicieron a otros alumnos..."></textarea>
                </div>
                <button id="save-material" class="w-full py-3 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition-all">Guardar Material en Nube</button>
                <div id="save-status" class="text-center mt-2 font-medium"></div>
            </div>

            <!-- TAB: MODO CHOICE (NUEVA ESTRUCTURA) -->
            <div id="tab-choice" class="tab-panel space-y-6">

                <!-- 1. Selección de Modo (NUEVO) -->
                <div id="choice-mode-selection" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div id="btn-load-choice" class="mode-card">
                        <svg data-lucide="upload-cloud" class="w-12 h-12 text-purple-600 mb-4"></svg>
                        <h3 class="text-xl font-bold">Cargar o Generar</h3>
                        <p class="text-gray-500 mt-2">Analizar PDFs o generar preguntas desde tu teoría.</p>
                    </div>
                    <div id="btn-practice-choice" class="mode-card">
                        <svg data-lucide="check-circle-2" class="w-12 h-12 text-green-600 mb-4"></svg>
                        <h3 class="text-xl font-bold">Practicar Choice</h3>
                        <p class="text-gray-500 mt-2">Practicar las preguntas clasificadas por tema.</p>
                    </div>
                </div>

                <!-- 2. Pantalla Cargar/Generar (NUEVO) -->
                <div id="choice-load-container" class="hidden space-y-6">
                    <button id="back-mode-choice-1" class="text-sm text-blue-600 font-bold flex items-center hover:underline">
                        <svg data-lucide="arrow-left" class="w-4 h-4 mr-1"></svg> Volver a selección
                    </button>
                    
                    <!-- Sección A: Analizar (UI Antigua) -->
                    <div class="p-6 border rounded-lg bg-gray-50">
                        <h3 class="text-xl font-bold text-gray-800 mb-2">1. Analizar Exámenes Existentes</h3>
                        <p class="text-sm text-gray-500 mb-4">Sube PDFs de choice o pega el texto para que la IA lo analice y clasifique.</p>
                        <div class="flex gap-2 mb-2">
                            <button class="upload-pdf-btn flex-1 py-2 bg-purple-100 text-purple-700 text-sm font-bold rounded hover:bg-purple-200" data-target="choice-raw">Subir PDF Choice</button>
                        </div>
                        <textarea id="choice-raw" rows="5" class="w-full p-2 border border-gray-300 rounded text-sm" placeholder="Pega aquí el texto de los exámenes..."></textarea>
                        <button id="analyze-choice-btn" class="w-full mt-2 py-2 bg-purple-600 text-white font-bold rounded hover:bg-purple-700 transition-all">
                            Analizar y Clasificar
                        </button>
                        <div id="analyze-choice-loader" class="hidden text-center mt-2">
                            <div class="loader w-6 h-6 border-2"></div>
                            <p class="text-xs text-gray-500 mt-1" id="choice-loader-text">Analizando...</p>
                        </div>
                    </div>

                    <!-- Sección B: Generar (NUEVO) -->
                    <div class="p-6 border rounded-lg bg-gray-50">
                        <h3 class="text-xl font-bold text-gray-800 mb-2">2. Generar Choice desde Teoría</h3>
                        <p class="text-sm text-gray-500 mb-4">Crea preguntas nuevas usando el contenido de tu pestaña "Material" (Teoría y Syllabus).</p>
                        <div class="flex items-center gap-4">
                            <label for="generate-choice-qty" class="font-semibold text-gray-700">Cantidad a generar:</label>
                            <select id="generate-choice-qty" class="p-2 border border-gray-300 rounded-lg">
                                <option value="5">5 Preguntas</option>
                                <option value="10">10 Preguntas</option>
                                <option value="20">20 Preguntas</option>
                            </select>
                            <button id="generate-choice-btn" class="flex-1 py-2 bg-green-600 text-white font-bold rounded hover:bg-green-700 transition-all">
                                Generar Preguntas
                            </button>
                        </div>
                        <div id="generate-choice-loader" class="loader hidden"></div>
                    </div>
                </div>

                <!-- 3. Pantalla Practicar (UI Antigua) -->
             <div id="choice-practice-container" class="hidden">
                    <div class="flex justify-between items-center mb-4">
                        <button id="back-mode-choice-2" class="text-sm text-blue-600 font-bold flex items-center hover:underline">
                            <svg data-lucide="arrow-left" class="w-4 h-4 mr-1"></svg> Volver a selección
                        </button>
                        <button id="toggle-sidebar-btn" class_attack="px-3 py-2 bg-gray-100 text-gray-700 rounded-lg hover:bg-gray-200" title="Modo Enfocado">
                            <svg data-lucide="panel-left-close" class="w-5 h-5"></svg>
                        </button>
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">
                        <div id="choice-sidebar-col" class="lg:col-span-1 space-y-6 border-r border-gray-200 pr-4">
                            <h3 class="text-xl font-bold text-gray-800 mb-4">Practicar por Tema</h3>
                            <div id="choice-loader-practice" class="loader hidden"></div>
                            <div id="choice-topics-list" class="space-y-2 max-h-[400px] overflow-y-auto pr-2">
                                <p class="text-sm text-gray-400 italic">No hay preguntas analizadas aún.</p>
                            </div>
                        </div>
                        <div id="choice-main-col" class="lg:col-span-2">
                            <div id="choice-practice-area" class="h-full flex flex-col justify-center items-center text-center p-8 bg-gray-50 rounded-xl border border-dashed border-gray-300">
                                <svg data-lucide="check-circle-2" class="w-16 h-16 text-gray-300 mb-4"></svg>
                                <h3 class="text-xl font-semibold text-gray-600">Zona de Práctica</h3>
                                <p class="text-gray-500 max-w-md mt-2">Selecciona un tema de la izquierda para comenzar a practicar.</p>
                            </div>
                        </div>
                    </div>
                </div>

            <!-- TAB: MODO ORAL / ESTUDIO -->
            <div id="tab-simulador" class="tab-panel space-y-6">
                <div id="mode-selection" class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div id="btn-study-mode" class="mode-card">
                        <svg data-lucide="book-open" class="w-12 h-12 text-blue-600 mb-4"></svg>
                        <h3 class="text-xl font-bold">Modo Estudio Guiado</h3>
                        <p class="text-gray-500 mt-2">Genera una estructura de temas inteligente usando *todo* tu material (Syllabus, Teoría y Choices).</p>
                    </div>
                    <div id="btn-exam-mode" class="mode-card">
                        <svg data-lucide="swords" class="w-12 h-12 text-red-600 mb-4"></svg>
                        <h3 class="text-xl font-bold">Simulacro Examen</h3>
                        <p class="text-gray-500 mt-2">Preguntas al azar de toda la materia, simulando la presión real.</p>
                    </div>
                </div>
                <!-- Contenedores ocultos -->
                <div id="study-container" class="hidden">
                    <button id="back-mode-1" class="mb-4 text-sm text-blue-600 font-bold flex items-center"><svg data-lucide="arrow-left" class="w-4 h-4 mr-1"></svg> Volver</button>
                    <h2 class="text-2xl font-bold mb-4">Estructura de Temas (IA)</h2>
                    <p class="text-sm text-gray-500 mb-4 -mt-2">Esta estructura se genera usando tu Syllabus, Teoría y Exámenes Choice.</p>
                    <div id="syllabus-browser" class="bg-gray-50 p-4 rounded-lg max-h-[400px] overflow-y-auto">
                        <div class="loader"></div>
                        <p class="text-center text-gray-500">Analizando todo el material...</p>
                    </div>
                    <div id="study-output" class="mt-6 space-y-6"></div>
                </div>
                <div id="exam-container" class="hidden">
                    <button id="back-mode-2" class="mb-4 text-sm text-blue-600 font-bold flex items-center"><svg data-lucide="arrow-left" class="w-4 h-4 mr-1"></svg> Volver</button>
                    <div class="bg-white p-6 rounded-lg border border-gray-200 text-center">
                        <label class="font-bold text-gray-700">Cantidad de preguntas:</label>
                        <input type="range" id="exam-qty" min="1" max="5" value="3" class="w-full mt-2">
                        <button id="generate-exam-btn" class="mt-4 px-6 py-2 bg-green-600 text-white font-bold rounded hover:bg-green-700">Generar Preguntas</button>
                    </div>
                    <div id="exam-output" class="mt-6 space-y-6"></div>
                </div>
            </div>

            <!-- TAB: REPASAR (MATERIA O GLOBAL) -->
            <div id="tab-review" class="tab-panel space-y-6">
                <div class="flex justify-between items-center bg-blue-50 p-4 rounded-lg border border-blue-100">
                    <div>
                        <h2 id="review-title" class="text-lg font-bold text-blue-900">Repaso (SRS)</h2>
                        <p id="review-subtitle" class="text-sm text-blue-700">Tarjetas de "Modo Oral" y flashcards de errores de "Modo Choice".</p>
                    </div>
                    <div class="text-right">
                        <span id="review-count" class="text-3xl font-extrabold text-blue-600">0</span>
                        <span class="text-xs block text-gray-500">pendientes</span>
                    </div>
                </div>
                <!-- Disclaimer de Vencidas -->
                <div id="review-overdue" class="overdue-disclaimer" style="display: none;"></div>
                
                <div id="review-loader" class="loader hidden"></div>
                <div id="review-list" class="space-y-4 min-h-[200px]">
                    <p class="text-gray-400 text-center py-10">Selecciona una materia (o "Ver Todas") para ver tus repasos.</p>
                </div>
            </div>

            <!-- TAB: ADMINISTRAR TEMAS (Ex-Unidades) -->
            <div id="tab-topics" class="tab-panel space-y-6">
                <h2 class="text-2xl font-bold text-gray-800">Administrar Temas</h2>
                <p class="text-gray-600">Organiza tus temas. Fusiona duplicados, renombra y crea subtemas para practicar.</p>
                
                <div id="topic-manager-controls" class="flex gap-2 p-4 bg-gray-50 rounded-lg border">
                    <button id="merge-topics-btn" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg text-sm disabled:opacity-50" disabled>Fusionar Seleccionados</button>
                    <button id="create-subtopic-btn" class="px-4 py-2 bg-green-600 text-white font-semibold rounded-lg text-sm disabled:opacity-50" disabled>Crear Subtema</button>
                </div>

                <div id="topic-manager-loader" class="text-center hidden">
                    <div class="loader"></div>
                    <p class="text-gray-500">Cargando todos los temas...</p>
                </div>
                <div id="topic-manager-list" class="space-y-2"></div>
            </div>

            <!-- TAB: HOJA de RUTA (MATERIA O GLOBAL) -->
            <div id="tab-roadmap" class="tab-panel space-y-6">
                <h2 id="roadmap-title" class="text-2xl font-bold text-gray-800">Hoja de Ruta</h2>
                <p id="roadmap-subtitle" class="text-gray-600">Cronograma de tus próximos repasos (Orales y Flashcards).</p>
                
                <div id="roadmap-loader" class="loader hidden"></div>
                <div id="roadmap-list" class="space-y-6"></div>
                <!-- Contenedor para la sesión de práctica de Hoja de Ruta -->
                <div id="roadmap-practice-session" class="hidden"></div>
            </div>

        </div>
    </div>

    <!-- Modal de Error -->
    <div id="error-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg max-w-sm w-full shadow-2xl">
            <h3 id="error-title" class="text-red-600 font-bold text-lg mb-2">Atención</h3>
            <p id="error-msg" class="text-gray-700 mb-4"></p>
            <button onclick="document.getElementById('error-modal').style.display='none'" class="w-full py-2 bg-gray-200 font-bold rounded hover:bg-gray-300">Cerrar</button>
        </div>
    </div>
    
    <!-- NUEVO: Modal de Confirmación para Borrar -->
    <div id="confirm-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white p-6 rounded-lg max-w-sm w-full shadow-2xl">
            <h3 id="confirm-title" class="text-yellow-600 font-bold text-lg mb-2">¿Estás seguro?</h3>
            <p id="confirm-msg" class="text-gray-700 mb-4">Esta acción no se puede deshacer.</p>
            <div class="flex justify-end gap-3">
                <button id="confirm-no" class="px-4 py-2 bg-gray-200 font-semibold rounded-lg hover:bg-gray-300">Cancelar</button>
                <button id="confirm-yes" class="px-4 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700">Sí, Eliminar</button>
            </div>
        </div>
    </div>

    <!-- Modal Edición de Flashcard (Anki) -->
    <div id="edit-qa-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg max-w-lg w-full shadow-2xl">
            <!-- Título dinámico -->
            <h3 id="edit-qa-title" class="text-xl font-bold text-gray-800 mb-4">Editar Flashcard</h3>
            <!-- Campos ocultos -->
            <input type="hidden" id="edit-qa-id">
            <input type="hidden" id="edit-qa-subject">
            <input type="hidden" id="edit-qa-unit">
            <input type="hidden" id="edit-qa-topic">
            
            <div class="space-y-3">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Pregunta</label>
                    <textarea id="edit-qa-question" rows="3" class="w-full p-2 border border-gray-300 rounded"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">Respuesta</label>
                    <textarea id="edit-qa-answer" rows="4" class="w-full p-2 border border-gray-300 rounded"></textarea>
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-700">URL de Imagen (Opcional)</label>
                    <input type="text" id="edit-qa-image" class="w-full p-2 border border-gray-300 rounded" placeholder="https://ejemplo.com/imagen.jpg">
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="edit-qa-cancel" class="px-4 py-2 bg-gray-200 font-semibold rounded-lg hover:bg-gray-300">Cancelar</button>
                <button id="edit-qa-save" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">Guardar</button>
            </div>
        </div>
    </div>

    <!-- INICIO: NUEVO Modal Edición de MCQ -->
    <div id="edit-mcq-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg max-w-2xl w-full shadow-2xl overflow-y-auto max-h-[90vh]">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Editar Pregunta Choice</h3>
            <input type="hidden" id="edit-mcq-id">
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-gray-700">Pregunta</label>
                    <textarea id="edit-mcq-question" rows="3" class="w-full p-2 border border-gray-300 rounded"></textarea>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-700">Opciones (Marcar la correcta)</label>
                    <div id="edit-mcq-options-container" class="space-y-2 mt-1">
                        <!-- Las opciones se generarán aquí dinámicamente -->
                    </div>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-700">Justificación (para Modo Inicial)</label>
                    <textarea id="edit-mcq-justification" rows="4" class="w-full p-2 border border-gray-300 rounded"></textarea>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="edit-mcq-cancel" class="px-4 py-2 bg-gray-200 font-semibold rounded-lg hover:bg-gray-300">Cancelar</button>
                <button id="edit-mcq-save" class="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">Guardar Cambios</button>
            </div>
        </div>
    </div>
    <!-- FIN: NUEVO Modal Edición de MCQ -->

    <!-- Input oculto para PDF -->
    <input type="file" id="hidden-pdf-input" accept=".pdf" style="display: none;">

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, getDoc, collection, addDoc, query, 
            where, onSnapshot, updateDoc, deleteDoc, getDocs, serverTimestamp, 
            orderBy, writeBatch 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURACIÓN FIREBASE ---
        const firebaseConfig = {
             apiKey: "AIzaSyAVbIeEAHBfKU5eDqsELTyXkAcM-m5qUUM",
             authDomain: "simulador-examen-oral.firebaseapp.com",
             projectId: "simulador-examen-oral",
             storageBucket: "simulador-examen-oral.firebasestorage.app",
             messagingSenderId: "64722873532",
             appId: "1:64722873532:web:2f708ee4a62366598c34b9"
        };
        
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // --- ESTADO GLOBAL ---
        let userId = localStorage.getItem('my_sync_userId');
        let currentSubject = null; // Materia seleccionada
        let allSubjectNames = []; // Array de nombres de materias
        let currentTab = 'tab-material'; // Iniciar en Material
        let unsubscribeReview = null;
        let unsubscribeRoadmap = null;
        
        // Estado para Modo Choice
        let cachedMcqs = []; 
        let currentPracticeTopic = null;
        let allPracticeTopicNames = []; 
        let currentPracticeQuestions = [];
        let currentQuestionIndex = 0;
        let currentQuizCorrect = 0;
        let currentQuizWrong = 0;
        let currentQuizWrongCards = [];
        let isFlashcardCreated = false;
        let currentPracticeMode = 'normal'; // NUEVO: 'normal' o 'inicial'

        // --- ELEMENTOS DOM ---
        const els = {
            tabs: document.querySelectorAll('.tab-button'),
            panels: document.querySelectorAll('.tab-panel'),
            subjectHeader: document.getElementById('subject-header'),
            subjectSelect: document.getElementById('subject-selector'),
            newSubjectInput: document.getElementById('new-subject-name'),
            addSubjectBtn: document.getElementById('add-subject-btn'),
            pdfInput: document.getElementById('hidden-pdf-input'),
            // Choice (NUEVA ESTRUCTURA)
            choiceModeSelection: document.getElementById('choice-mode-selection'),
            btnLoadChoice: document.getElementById('btn-load-choice'),
            btnPracticeChoice: document.getElementById('btn-practice-choice'),
            choiceLoadContainer: document.getElementById('choice-load-container'),
            choicePracticeContainer: document.getElementById('choice-practice-container'),
            backModeChoice1: document.getElementById('back-mode-choice-1'),
            backModeChoice2: document.getElementById('back-mode-choice-2'),
            choiceRaw: document.getElementById('choice-raw'),
            analyzeBtn: document.getElementById('analyze-choice-btn'),
            analyzeChoiceLoader: document.getElementById('analyze-choice-loader'), // Renombrado
            choiceLoaderText: document.getElementById('choice-loader-text'), 
            generateChoiceQty: document.getElementById('generate-choice-qty'),
            generateChoiceBtn: document.getElementById('generate-choice-btn'),
            generateChoiceLoader: document.getElementById('generate-choice-loader'),
            choiceList: document.getElementById('choice-topics-list'),
            choiceLoaderPractice: document.getElementById('choice-loader-practice'),
            practiceArea: document.getElementById('choice-practice-area'),
            // Oral
            studyModeBtn: document.getElementById('btn-study-mode'),
            examModeBtn: document.getElementById('btn-exam-mode'),
            modeSelection: document.getElementById('mode-selection'),
            studyContainer: document.getElementById('study-container'),
            examContainer: document.getElementById('exam-container'),
            syllabusBrowser: document.getElementById('syllabus-browser'),
            // Review
            reviewTitle: document.getElementById('review-title'),
            reviewSubtitle: document.getElementById('review-subtitle'),
            reviewOverdue: document.getElementById('review-overdue'),
            reviewLoader: document.getElementById('review-loader'),
            reviewList: document.getElementById('review-list'),
            reviewCount: document.getElementById('review-count'),
            // Admin Temas
            topicManagerLoader: document.getElementById('topic-manager-loader'),
            topicManagerList: document.getElementById('topic-manager-list'),
            mergeTopicsBtn: document.getElementById('merge-topics-btn'),
            createSubtopicBtn: document.getElementById('create-subtopic-btn'),
            // Roadmap
            roadmapTitle: document.getElementById('roadmap-title'),
            roadmapSubtitle: document.getElementById('roadmap-subtitle'),
            roadmapLoader: document.getElementById('roadmap-loader'),
            roadmapList: document.getElementById('roadmap-list'),
            roadmapPractice: document.getElementById('roadmap-practice-session'),
            // Modales
            editQaModal: document.getElementById('edit-qa-modal'),
            editQaTitle: document.getElementById('edit-qa-title'),
            editQaId: document.getElementById('edit-qa-id'),
            editQaSubject: document.getElementById('edit-qa-subject'),
            editQaUnit: document.getElementById('edit-qa-unit'),
            editQaTopic: document.getElementById('edit-qa-topic'),
            editQaQuestion: document.getElementById('edit-qa-question'),
            editQaAnswer: document.getElementById('edit-qa-answer'),
            editQaImage: document.getElementById('edit-qa-image'),
            // NUEVO: Modal Confirmación
            confirmModal: document.getElementById('confirm-modal'),
            confirmMsg: document.getElementById('confirm-msg'),
            confirmYes: document.getElementById('confirm-yes'),
            confirmNo: document.getElementById('confirm-no'),
            // NUEVO: Modal Edición MCQ
            editMcqModal: document.getElementById('edit-mcq-modal'),
            editMcqId: document.getElementById('edit-mcq-id'),
            editMcqQuestion: document.getElementById('edit-mcq-question'),
            editMcqOptionsContainer: document.getElementById('edit-mcq-options-container'),
            editMcqJustification: document.getElementById('edit-mcq-justification'),
        };

        // --- INICIALIZACIÓN ---
        async function init() {
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    if (!userId) {
                        document.getElementById('sync-modal').style.display = 'flex';
                    } else {
                        document.getElementById('user-id').textContent = userId;
                        document.getElementById('sync-id-display').style.display = 'block';
                        await loadSubjects(); 
                        els.subjectHeader.style.display = 'block'; // Mostrar selector
                        switchTab(currentTab); // Cargar la pestaña inicial (Material)
                        if (typeof lucide !== 'undefined') lucide.createIcons();
                    }
                }
            });
            await signInAnonymously(auth);
            setupListeners();
        }

        function setupListeners() {
            // Tabs
            els.tabs.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const target = e.target.id.replace('-btn', '');
                    switchTab(target);
                });
            });
            
            // Sync Modal
            document.getElementById('save-sync-id').onclick = () => {
                const val = document.getElementById('sync-id-input').value.trim();
                if(val) { localStorage.setItem('my_sync_userId', val); location.reload(); }
            };
            document.getElementById('generate-sync-id').onclick = () => {
                localStorage.setItem('my_sync_userId', crypto.randomUUID()); location.reload();
            };

            // NUEVO: Botón para cambiar ID
            document.getElementById('change-sync-id').onclick = () => {
                const newId = prompt("Ingresa tu ID de Sincronización. (Dejar en blanco para generar uno nuevo).", userId);
                if (newId === null) return; // Apretó "Cancelar"
                
                if (newId.trim() === "") {
                    // Generar uno nuevo
                    localStorage.setItem('my_sync_userId', crypto.randomUUID());
                } else {
                    // Usar el que ingresó
                    localStorage.setItem('my_sync_userId', newId.trim());
                }
                location.reload();
            };

            // Subjects
            els.addSubjectBtn.onclick = createSubject;
            els.subjectSelect.onchange = changeSubject;

            // PDF Uploads
            document.querySelectorAll('.upload-pdf-btn').forEach(btn => {
                btn.onclick = () => {
                    els.pdfInput.dataset.target = btn.dataset.target;
                    els.pdfInput.click();
                };
            });
            els.pdfInput.onchange = handlePdfFile;

            // Material Saving
            document.getElementById('save-material').onclick = saveMaterial;

            // --- Choice Mode Listeners (NUEVO) ---
            els.btnLoadChoice.onclick = () => {
                els.choiceModeSelection.style.display = 'none';
                els.choiceLoadContainer.style.display = 'block';
            };
            els.btnPracticeChoice.onclick = () => {
                els.choiceModeSelection.style.display = 'none';
                els.choicePracticeContainer.style.display = 'block';
                // Cargar temas si no están ya cargados
                if (els.choiceList.innerHTML.includes('italic')) {
                    loadChoiceTopics();
                }
            };
            els.backModeChoice1.onclick = () => {
                els.choiceModeSelection.style.display = 'grid';
                els.choiceLoadContainer.style.display = 'none';
            };
            els.backModeChoice2.onclick = () => {
                els.choiceModeSelection.style.display = 'grid';
                els.choicePracticeContainer.style.display = 'none';
            };
            els.analyzeBtn.onclick = handleAnalyzeChoice;
            els.generateChoiceBtn.onclick = handleGenerateChoice; // NUEVO
            // NUEVO: Listener Modo Enfocado
            document.getElementById('toggle-sidebar-btn').onclick = toggleFocusMode;
            
            // Oral Modes
            els.studyModeBtn.onclick = () => { els.modeSelection.classList.add('hidden'); els.studyContainer.classList.remove('hidden'); loadSyllabusBrowser(); };
            els.examModeBtn.onclick = () => { els.modeSelection.classList.add('hidden'); els.examContainer.classList.remove('hidden'); };
            document.getElementById('back-mode-1').onclick = resetModes;
            document.getElementById('back-mode-2').onclick = resetModes;
            document.getElementById('generate-exam-btn').onclick = generateOralExam;

            // Admin Temas Listeners
            els.mergeTopicsBtn.onclick = mergeSelectedTopics;
            els.createSubtopicBtn.onclick = createSubtopicFromSelected;

            // --- INICIO: Listeners para Modo Estudio (de V6) ---
            els.syllabusBrowser.addEventListener('click', (e) => {
                // Maneja el toggle del acordeón de Unidad
                const unitBtn = e.target.closest('.unit-toggle-btn');
                if (unitBtn) {
                    const content = unitBtn.nextElementSibling;
                    // Reutilizamos la función toggleAccordion que ya arreglamos
                    toggleAccordion(unitBtn, content); 
                    return; // Evita que se dispare el de tema
                }
                
                // Maneja la selección de un Tema
                const topicBtn = e.target.closest('.syllabus-topic-btn');
                if (topicBtn) {
                    handleStudyTopicSelect(topicBtn);
                }
            });

            document.getElementById('study-output').addEventListener('click', (e) => {
                const answerBtn = e.target.closest('.answer-btn');
                if (answerBtn) {
                    handleAnswerClick(answerBtn);
                    return;
                }
                
                const saveBtn = e.target.closest('.save-btn');
                if (saveBtn) {
                    handleSaveClick(saveBtn);
                    return;
                }

                const generateMoreBtn = e.target.closest('.generate-more-btn');
                if (generateMoreBtn) {
                    handleGenerateMoreQuestions(generateMoreBtn);
                    return;
                }
            });
            // --- FIN: Listeners para Modo Estudio (de V6) ---

            // Modal Edición
            document.getElementById('edit-qa-cancel').onclick = () => els.editQaModal.style.display = 'none';
            document.getElementById('edit-qa-save').onclick = saveEditQa;
            
            // NUEVO: Modal Confirmación
            els.confirmNo.onclick = () => els.confirmModal.style.display = 'none';

            // NUEVO: Listeners Modal Edición MCQ
            document.getElementById('edit-mcq-cancel').onclick = () => els.editMcqModal.style.display = 'none';
            document.getElementById('edit-mcq-save').onclick = saveEditMcq;
        }

        // --- FUNCIONES CORE ---
        
        function switchTab(tabId) {
            currentTab = tabId;
            els.tabs.forEach(t => t.classList.remove('active'));
            els.panels.forEach(p => p.classList.remove('active'));
            document.getElementById(tabId + '-btn').classList.add('active');
            document.getElementById(tabId).classList.add('active');
            
            // Cargar datos de la pestaña activa si hay materia seleccionada
            if (currentSubject) {
                loadDataForCurrentTab(tabId);
            }
        }

        async function loadSubjects() {
            try {
                const ref = collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects');
                const snap = await getDocs(ref);
                els.subjectSelect.innerHTML = `
                    <option value="">-- Seleccionar --</option>
                    <option value="all">-- Ver Todas --</option>
                `;
                allSubjectNames = []; // Resetear
                snap.forEach(d => {
                    allSubjectNames.push(d.id); // Guardar nombres
                    const opt = document.createElement('option');
                    opt.value = d.id; opt.textContent = d.id;
                    els.subjectSelect.appendChild(opt);
                });
            } catch (error) {
                console.error("Error fatal al cargar materias:", error);
                showError("Error al cargar materias. Revisa los permisos de Firestore.");
                els.subjectHeader.innerHTML = '<p class="text-red-500">Error al cargar materias.</p>';
            }
        }

        async function createSubject() {
            const name = els.newSubjectInput.value.trim();
            if (!name) return;
            try {
                await setDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', name), { created: serverTimestamp() });
                await loadSubjects();
                els.subjectSelect.value = name;
                await changeSubject(); 
            } catch (e) {
                console.error("Error creating subject: ", e);
                showError("Error al crear la materia. Revisa la consola.");
            }
        }

        async function changeSubject() {
            currentSubject = els.subjectSelect.value;
            
            if (unsubscribeReview) unsubscribeReview();
            if (unsubscribeRoadmap) unsubscribeRoadmap();
            
            clearAllTabs();

            // Cargar datos proactivamente
            if (currentSubject && currentSubject !== 'all') {
                // Seleccionó una materia específica
                showLoadingOnTabs(true, true); // Carga completa
                try {
                    await Promise.all([
                        loadMaterialFields(),
                        loadChoiceTopics(),
                        loadTopicManager(),
                        loadReviewData(currentSubject),
                        loadRoadmapData(currentSubject)
                    ]);
                } catch (error) {
                    console.error("Error al cargar datos de la materia:", error);
                    showError("Error al cargar datos de la materia. Revisa la consola.");
                }
                showLoadingOnTabs(false, true);
            } else if (currentSubject === 'all') {
                // Seleccionó "Ver Todas"
                showLoadingOnTabs(true, false); // Carga parcial (solo review/roadmap)
                try {
                     await Promise.all([
                        loadReviewData('all'),
                        loadRoadmapData('all')
                    ]);
                } catch (error) {
                     console.error("Error al cargar datos globales:", error);
                }
                showLoadingOnTabs(false, false);
            }
            // Mostrar la pestaña actual (se llama desde switchTab, así que no es necesario aquí)
            // loadDataForCurrentTab(currentTab);
        }
        
        // Cargar datos solo para la pestaña activa (se llama desde switchTab)
        function loadDataForCurrentTab(tabId) {
            const subject = currentSubject;
            if (!subject) return; // No hacer nada si no hay materia

            if (subject === 'all') {
                if (tabId === 'review') loadReviewData('all');
                if (tabId === 'roadmap') loadRoadmapData('all');
            } else {
                if (tabId === 'material') loadMaterialFields();
                if (tabId === 'choice') loadChoiceTopics();
                if (tabId === 'topics') loadTopicManager();
                if (tabId === 'review') loadReviewData(subject);
                if (tabId === 'roadmap') loadRoadmapData(subject);
            }
        }
        
        function showLoadingOnTabs(isLoading, isFullLoad) {
            const loaders = [els.reviewLoader, els.roadmapLoader];
            if (isFullLoad) {
                loaders.push(els.topicManagerLoader, els.choiceLoaderPractice);
            }
            
            loaders.forEach(loader => {
                if (loader) loader.style.display = isLoading ? 'block' : 'none';
            });
        }
        
        function clearAllTabs() {
            els.choiceList.innerHTML = '<p class="text-gray-400 italic">Selecciona una materia.</p>';
            els.practiceArea.innerHTML = '<p class="text-gray-400">Selecciona un tema.</p>';
            els.syllabusBrowser.innerHTML = '<p class="text-gray-400">Selecciona una materia.</p>';
            els.reviewList.innerHTML = '<p class="text-gray-400 text-center py-10">Selecciona una materia (o "Ver Todas").</p>';
            els.roadmapList.innerHTML = '<p class="text-gray-400 text-center py-10">Selecciona una materia (o "Ver Todas").</p>';
            els.topicManagerList.innerHTML = '<p class="text-gray-400 text-center py-10">Selecciona una materia.</p>';
            
            // Limpiar material
            loadMaterialFields(true);
            
            // Resetear UI de Choice
            els.choiceModeSelection.style.display = 'grid';
            els.choiceLoadContainer.style.display = 'none';
            els.choicePracticeContainer.style.display = 'none';

            // Limpiar títulos
            els.reviewTitle.textContent = "Repaso (SRS)";
            els.reviewSubtitle.textContent = "Selecciona una materia o 'Ver Todas'.";
            els.roadmapTitle.textContent = "Hoja de Ruta";
            els.roadmapSubtitle.textContent = "Selecciona una materia o 'Ver Todas'.";
            
            // Ocultar loaders y disclaimers
            showLoadingOnTabs(false, true);
            els.reviewOverdue.style.display = 'none';
        }

        // --- LÓGICA MATERIAL (PDF & SAVE) ---
        
        async function handlePdfFile(e) {
            const file = e.target.files[0];
            if(!file) return;
            const targetId = e.target.dataset.target;
            const textarea = document.getElementById(targetId);
            const prevText = textarea.placeholder;
            textarea.placeholder = "Procesando PDF...";
            try {
                const buffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument(buffer).promise;
                let fullText = "\n\n--- CONTENIDO PDF: " + file.name + " ---\n";
                for(let i=1; i<=pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const content = await page.getTextContent();
                    fullText += content.items.map(item => item.str).join(' ') + "\n";
                }
                textarea.value += fullText;
                textarea.placeholder = prevText;
                showError("PDF cargado correctamente (añadido al final del texto).", false);
            } catch(err) {
                console.error(err);
                showError("Error leyendo PDF. Asegúrate de que sea un PDF de texto seleccionable.");
            }
            e.target.value = '';
        }

        async function saveMaterial() {
            if (!currentSubject || currentSubject === 'all') return showError("Selecciona una materia específica para guardar.");
            const data = {
                syllabus: document.getElementById('syllabus').value,
                theory: document.getElementById('theory').value,
                experiences: document.getElementById('experiences').value
            };
            for(const [key, val] of Object.entries(data)) {
                await setDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'materials', key), { content: val });
            }
            document.getElementById('save-status').textContent = "¡Guardado exitoso!";
            setTimeout(() => document.getElementById('save-status').textContent = '', 3000);
        }

        async function loadMaterialFields(clear = false) {
            const fields = ['syllabus', 'theory', 'experiences', 'choice-raw'];
            if (clear) {
                fields.forEach(key => {
                    const el = document.getElementById(key);
                    if (el) el.value = '';
                });
                return;
            }
            if (!currentSubject || currentSubject === 'all') return;
            for(const key of ['syllabus', 'theory', 'experiences']) {
                try {
                    const d = await getDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'materials', key));
                    document.getElementById(key).value = d.exists() ? d.data().content : '';
                } catch(e) {
                    console.warn(`No se pudo cargar material: ${key}`, e);
                    document.getElementById(key).value = '';
                }
            }
            document.getElementById('choice-raw').value = '';
        }
        
        // --- FUNCIÓN DE PARTCIONADO (CHUNKING) ---
        function chunkText(text, size = 15000) {
            const chunks = [];
            for (let i = 0; i < text.length; i += size) {
                chunks.push(text.substring(i, i + size));
            }
            return chunks;
        }
        
        // --- LÓGICA DE REPASO (GLOBAL O POR MATERIA) ---

        async function loadReviewData(subject) {
            els.reviewLoader.style.display = 'block';
            els.reviewList.innerHTML = '';
            els.reviewOverdue.style.display = 'none';

            if (subject === 'all') {
                els.reviewTitle.textContent = "Repaso Global (Todas las Materias)";
                els.reviewSubtitle.textContent = "Tarjetas vencidas de todas tus materias.";
            } else {
                els.reviewTitle.textContent = `Repaso (SRS) - ${subject}`;
                els.reviewSubtitle.textContent = "Tarjetas de Oral y Choice para esta materia.";
            }

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            let allDueCards = [];

            try {
                const subjectsToQuery = (subject === 'all') ? allSubjectNames : [subject];
                for (const subj of subjectsToQuery) {
                    const q = query(
                        collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', subj, 'saved_questions'),
                        where('nextReviewDate', '<=', now)
                    );
                    const snap = await getDocs(q);
                    snap.forEach(d => {
                        allDueCards.push({ id: d.id, subject: subj, ...d.data() });
                    });
                }
                
                els.reviewLoader.style.display = 'none';
                els.reviewCount.textContent = allDueCards.length;

                // Disclaimer de Vencidas
                const overdueCount = allDueCards.filter(c => c.nextReviewDate.toDate() < today).length;
                if (overdueCount > 0) {
                    els.reviewOverdue.textContent = `[!] ¡Atención! Tienes ${overdueCount} tarjetas vencidas de días anteriores. Se mostrarán primero.`;
                    els.reviewOverdue.style.display = 'block';
                }
                
                // Renderizar
                renderReviewCards(allDueCards, subject === 'all');

            } catch (error) {
                console.error("Error cargando repasos:", error);
                els.reviewLoader.style.display = 'none';
                els.reviewList.innerHTML = '<p class="text-red-500">Error al cargar repasos. Revisa la consola.</p>';
            }
        }

        // --- LÓGICA DE HOJA DE RUTA (GLOBAL O POR MATERIA) ---

        async function loadRoadmapData(subject) {
            els.roadmapLoader.style.display = 'block';
            els.roadmapList.innerHTML = '';
            els.roadmapPractice.innerHTML = '';
            els.roadmapPractice.style.display = 'none';

            if (subject === 'all') {
                els.roadmapTitle.textContent = "Hoja de Ruta Global";
                els.roadmapSubtitle.textContent = "Próximos repasos de todas tus materias.";
            } else {
                els.roadmapTitle.textContent = `Hoja de Ruta - ${subject}`;
                els.roadmapSubtitle.textContent = "Próximos repasos para esta materia.";
            }

            const now = new Date();
            let allFutureCards = [];
            
            try {
                const subjectsToQuery = (subject === 'all') ? allSubjectNames : [subject];
                for (const subj of subjectsToQuery) {
                    const q = query(
                        collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', subj, 'saved_questions'),
                        where('nextReviewDate', '>', now)
                    );
                    const snap = await getDocs(q);
                    snap.forEach(d => {
                        allFutureCards.push({ id: d.id, subject: subj, ...d.data() });
                    });
                }

                els.roadmapLoader.style.display = 'none';
                
                if (allFutureCards.length === 0) {
                    els.roadmapList.innerHTML = '<p class="text-gray-400">No hay repasos futuros.</p>';
                    return;
                }

                // Agrupar por día
                allFutureCards.sort((a,b) => a.nextReviewDate.toMillis() - b.nextReviewDate.toMillis());
                const groupedByDay = allFutureCards.reduce((acc, card) => {
                    const date = card.nextReviewDate.toDate().toLocaleDateString();
                    if (!acc[date]) acc[date] = [];
                    acc[date].push(card);
                    return acc;
                }, {});

                // Renderizar
                renderRoadmapAccordions(groupedByDay, subject === 'all');

            } catch (error) {
                console.error("Error cargando hoja de ruta:", error);
                els.roadmapLoader.style.display = 'none';
                els.roadmapList.innerHTML = '<p class="text-red-500">Error al cargar la hoja de ruta.</p>';
            }
        }

        // --- MODO CHOICE (LÓGICA COMPLETA) ---

        async function handleAnalyzeChoice() {
            const rawText = els.choiceRaw.value;
            if (!rawText.trim()) return showError("No hay texto de examen para analizar.");
            if (!currentSubject || currentSubject === 'all') return showError("Selecciona una materia específica.");

            els.analyzeBtn.disabled = true;
            els.analyzeChoiceLoader.style.display = 'block';

            try {
                const syllabus = document.getElementById('syllabus').value;
                const theory = document.getElementById('theory').value;
                const textChunks = chunkText(rawText);
                let allParsedQuestions = [];
                
                for (let i = 0; i < textChunks.length; i++) {
                    els.choiceLoaderText.textContent = `Analizando trozo ${i + 1} de ${textChunks.length}...`;
                    const chunk = textChunks[i];
                    // --- MODIFICADO: Ahora el prompt pide 'correctIndex' ---
                    const parsedQuestions = await callGeminiForChoice(chunk, syllabus, theory);
                    allParsedQuestions = allParsedQuestions.concat(parsedQuestions);
                }
                
                els.choiceLoaderText.textContent = `Guardando ${allParsedQuestions.length} preguntas...`;

                const batch = writeBatch(db);
                allParsedQuestions.forEach(q => {
                    const docRef = doc(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq'));
                    batch.set(docRef, {
                        ...q,
                        createdAt: serverTimestamp(),
                        status: 'new',
                        isVerified: false // NUEVO: Marcar como no verificado
                    });
                });
                await batch.commit();

                els.choiceRaw.value = '';
                showError(`¡Éxito! Se clasificaron ${allParsedQuestions.length} preguntas.`, false);
                await loadChoiceTopics(); // Recargar temas
                // Cambiar a la pestaña de práctica
                els.choiceLoadContainer.style.display = 'none';
                els.choicePracticeContainer.style.display = 'block';

            } catch (err) {
                console.error(err);
                showError("Error al analizar: " + err.message);
            } finally {
                els.analyzeBtn.disabled = false;
                els.analyzeChoiceLoader.style.display = 'none';
                els.choiceLoaderText.textContent = "Analizando...";
            }
        }
        
        // --- NUEVA FUNCIÓN: Generar Choice desde Teoría ---
        async function handleGenerateChoice() {
            if (!currentSubject || currentSubject === 'all') return showError("Selecciona una materia específica.");
            
            const qty = els.generateChoiceQty.value;
            els.generateChoiceBtn.disabled = true;
            els.generateChoiceLoader.style.display = 'block';

            try {
                const syllabus = document.getElementById('syllabus').value;
                const theory = document.getElementById('theory').value;
                
                if (!syllabus.trim() && !theory.trim()) {
                    throw new Error("La pestaña 'Material' (Syllabus o Teoría) está vacía. No se puede generar preguntas.");
                }

               // --- MODIFICADO: El prompt ahora pide 'correctIndex' y 4 o 5 opciones ---
                const prompt = `
                    Basado en el siguiente material de estudio:
                    --- PLAN DE ESTUDIO ---
                    ${syllabus.substring(0, 5000)}
                    --- TEORÍA ---
                    ${theory.substring(0, 10000)}
                    
                    Genera exactamente ${qty} preguntas de opción múltiple (Choice) de alta calidad.
                    Para CADA pregunta, asigna un 'topic' y 'unit' basándote en el material.
                    Asegúrate de que las opciones sean 4 o 5, y la justificación sea clara.
                    Responde SOLO con un JSON Array: [{ "question": "...", "options": ["A", "B", "C", "D", "E"], "correctIndex": 0 (un número, ej: 0, 1, 2, 3, 4...), "topic": "...", "unit": "...", "justification": "..." }]
                `;
                
                let txt = await callGeminiAPI(prompt, true);
                const generatedQuestions = parseJsonFromAi(txt);

                const batch = writeBatch(db);
                generatedQuestions.forEach(q => {
                    const docRef = doc(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq'));
                    batch.set(docRef, {
                        ...q,
                        createdAt: serverTimestamp(),
                        status: 'new',
                        isVerified: true // NUEVO: Marcar como verificado (confiamos más en la generación)
                    });
                });
                await batch.commit();

                showError(`¡Éxito! Se generaron ${generatedQuestions.length} preguntas nuevas.`, false);
                await loadChoiceTopics(); // Recargar temas
                // Cambiar a la pestaña de práctica
                els.choiceLoadContainer.style.display = 'none';
                els.choicePracticeContainer.style.display = 'block';

            } catch (err) {
                console.error(err);
                showError("Error al generar preguntas: " + err.message);
            } finally {
                els.generateChoiceBtn.disabled = false;
                els.generateChoiceLoader.style.display = 'none';
            }
        }

        function parseJsonFromAi(txt) {
            try {
                txt = txt.replace(/\\\[/g, '[').replace(/\\\]/g, ']'); // Corregir escapes
                const jsonMatch = txt.match(/\[\s*\{.*\}\s*\]/s); // Extraer solo el array
                let jsonToParse = (jsonMatch && jsonMatch[0]) ? jsonMatch[0] : txt;
                return JSON.parse(jsonToParse);
            } catch (e) {
                console.error("Falló el parseo de JSON. Error:", e, "Respuesta original de IA:", txt);
                throw new Error("La IA devolvió un JSON malformado. Revisa la consola.");
            }
        }

        async function callGeminiForChoice(examText, syllabus, theory) {
            // --- MODIFICADO: El prompt ahora pide 'correctIndex' y 5 opciones ---
            const prompt = `
                Analiza este texto de examen Choice.
                Contexto Syllabus: ${syllabus.substring(0, 2000)}...
                Contexto Teoría: ${theory.substring(0, 2000)}...
                Texto Examen: ${examText}
                Tarea: Extrae preguntas, todas las opciones (pueden ser 4, 5 o más), 'topic', 'unit' (basado en Syllabus), y 'justification'.
                IMPORTANTE: Deduce cuál es la respuesta correcta y devuélvela como 'correctIndex' (un número, ej: 0, 1, 2, 3, 4...).
                Responde SOLO un JSON Array: [{ "question": "...", "options": ["A", "B", "C", "D", "E"], "correctIndex": 0, "topic": "...", "unit": "...", "justification": "..." }]
            `;
            let txt = await callGeminiAPI(prompt, true);
            return parseJsonFromAi(txt);
        }

        async function loadChoiceTopics() {
            if (!currentSubject || currentSubject === 'all') {
                 els.choiceList.innerHTML = '<p class="text-sm text-gray-400 italic">Selecciona una materia para ver sus temas.</p>';
                 return;
            }
            els.choiceLoaderPractice.style.display = 'block';
            els.choiceList.innerHTML = '';
            
            const q = query(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq'));
            const snap = await getDocs(q);
            cachedMcqs = snap.docs.map(d => ({ id: d.id, ...d.data() }));
            
            const topics = {};
            cachedMcqs.forEach(m => {
                const topicName = m.topic || "Sin Clasificar";
                if(!topics[topicName]) topics[topicName] = { total: 0, mastered: 0, name: topicName, questions: [] };
                topics[topicName].total++;
                topics[topicName].questions.push(m);
                if(m.status === 'mastered') topics[topicName].mastered++;
            });

            els.choiceLoaderPractice.style.display = 'none';
            
            if (Object.keys(topics).length === 0) {
                 els.choiceList.innerHTML = '<p class="text-sm text-gray-400 italic">No hay preguntas analizadas aún.</p>';
                 return;
            }
            
            allPracticeTopicNames = Object.values(topics).sort((a,b) => a.name.localeCompare(b.name));
            
            allPracticeTopicNames.forEach(t => {
                const pct = Math.round((t.mastered / t.total) * 100);
                const div = document.createElement('div');
                div.className = 'p-3 bg-white border rounded hover:bg-gray-50 cursor-pointer transition';
                div.innerHTML = `
                    <div class="flex justify-between mb-1">
                        <span class="font-bold text-sm">${t.name}</span>
                        <span class="text-xs text-gray-500">${t.mastered}/${t.total}</span>
                    </div>
                    <div class="progress-bar-container h-2"><div class="progress-bar-fill" style="width: ${pct}%"></div></div>
                `;
                // --- MODIFICADO: Ahora muestra el menú de modo ---
                div.onclick = () => showPracticeModeMenu(t.name);
                els.choiceList.appendChild(div);
            });
        }

        // --- INICIO: NUEVAS Funciones para Modos de Práctica ---
        function showPracticeModeMenu(topicName) {
            currentPracticeTopic = topicName;
            els.practiceArea.innerHTML = `
                <div class="practice-mode-menu max-w-md mx-auto">
                    <h3 class="text-lg font-bold text-center mb-2">Practicar: ${topicName}</h3>
                    <button class="practice-mode-btn" onclick="startPracticeSession('${topicName}', 'inicial')">
                        Modo Inicial
                        <span>Incluye explicaciones y justificaciones. Ideal para aprender.</span>
                    </button>
                    <button class="practice-mode-btn" onclick="startPracticeSession('${topicName}', 'normal')">
                        Modo Normal
                        <span>Práctica rápida sin ayudas. Ideal para autoevaluarse.</span>
                    </button>
                </div>
            `;
            // Hacemos que window pueda acceder a la función
            window.startPracticeSession = startPracticeSession;
        }

        function startPracticeSession(topic, mode) {
            currentPracticeMode = mode; // 'inicial' o 'normal'
            
            // Lógica de la antigua función startPractice
            currentPracticeQuestions = cachedMcqs.filter(m => (m.topic || "Sin Clasificar") === topic && m.status !== 'mastered');
            if(currentPracticeQuestions.length === 0) currentPracticeQuestions = cachedMcqs.filter(m => (m.topic || "Sin Clasificar") === topic);
            
            currentPracticeQuestions.sort(() => Math.random() - 0.5);
            currentQuestionIndex = 0;
            currentQuizCorrect = 0;
            currentQuizWrong = 0;
            currentQuizWrongCards = [];
            renderQuestion();
        }
        // --- FIN: NUEVAS Funciones para Modos de Práctica ---

        function renderQuestion() {
            if(currentQuestionIndex >= currentPracticeQuestions.length) {
                const total = currentPracticeQuestions.length;
                const score = currentQuizCorrect;
                const pct = total > 0 ? Math.round((score / total) * 100) : 0;
                
                const currentTopicIndex = allPracticeTopicNames.findIndex(t => t.name === currentPracticeTopic);
                const nextTopic = (currentTopicIndex > -1 && currentTopicIndex + 1 < allPracticeTopicNames.length) 
                                    ? allPracticeTopicNames[currentTopicIndex + 1] : null;

                els.practiceArea.innerHTML = `
                    <div class="text-center p-6">
                        <svg data-lucide="trophy" class="w-16 h-16 text-yellow-500 mx-auto mb-4"></svg>
                        <h3 class="text-2xl font-bold">¡Tema Completado!</h3>
                        <p class="text-xl text-gray-600 mt-2">Tu puntaje: <b class="text-blue-600">${score} / ${total} (${pct}%)</b></p>
                        
                        <div class="mt-6 flex flex-wrap justify-center gap-3">
                            <button id="choice-back" class="px-5 py-2 bg-gray-200 text-gray-800 font-semibold rounded-lg hover:bg-gray-300">Volver a Temas</button>
                            <button id="choice-retry" class="px-5 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700">Reintentar</button>
                            ${currentQuizWrong > 0 ? `<button id="choice-review-errors" class="px-5 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700">Repasar Errores (${currentQuizWrong})</button>` : ''}
                            ${nextTopic ? `<button id="choice-next-topic" class="px-5 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700">Siguiente Tema: ${nextTopic.name}</button>` : ''}
                        </div>
                    </div>`;
                
                document.getElementById('choice-back').onclick = () => {
                    // --- MODIFICADO: Vuelve al menú de temas, no al contenedor principal ---
                    els.practiceArea.innerHTML = ''; // Limpiar área
                    showPracticeModeMenu(currentPracticeTopic); // Mostrar menú del tema actual
                };
                // --- MODIFICADO: reintenta el modo actual ---
                document.getElementById('choice-retry').onclick = () => startPracticeSession(currentPracticeTopic, currentPracticeMode);
                if (document.getElementById('choice-review-errors')) {
                    document.getElementById('choice-review-errors').onclick = () => {
                        showError("¡Errores enviados! Revisa la pestaña 'Repasar' para estudiarlos con Anki.", false);
                        switchTab('review');
                    };
                }
                if (document.getElementById('choice-next-topic')) {
                    // --- MODIFICADO: va al siguiente tema, pero muestra el menú de modo ---
                    document.getElementById('choice-next-topic').onclick = () => showPracticeModeMenu(nextTopic.name);
                }
                
                if (typeof lucide !== 'undefined') lucide.createIcons();
                loadChoiceTopics();
                return;
            }

            isFlashcardCreated = false;
            const q = currentPracticeQuestions[currentQuestionIndex];
            const options = Array.isArray(q.options) ? q.options : [q.options];

            // --- INICIO: NUEVO (Modo Inicial) ---
            let justificationHtml = '';
            if (currentPracticeMode === 'inicial') {
                justificationHtml = `
                    <div class="mt-4">
                        <button class="justification-accordion-btn" id="justification-btn" aria-expanded="false">
                            <span>Ver Explicación</span>
                            <svg data-lucide="chevron-down" class="w-4 h-4"></svg>
                        </button>
                        <div class="justification-content" id="justification-content">
                            ${q.justification ? q.justification : '<p class="text-gray-400 italic">No hay justificación guardada. <a href="#" id="generate-justification-link" class="text-blue-600">Generar una</a></p>'}
                        </div>
                    </div>
                `;
            }
            // --- FIN: NUEVO ---

            els.practiceArea.innerHTML = `
                <div class="w-full max-w-2xl bg-white p-6 rounded-xl shadow-sm border border-gray-200 text-left">
                    <div class="flex justify-between text-xs text-gray-400 mb-2">
                        <span>${q.topic || "Sin Clasificar"}</span>
                        <span>Pregunta ${currentQuestionIndex + 1} de ${currentPracticeQuestions.length}</span>
                    </div>
                    <h3 class="text-lg font-bold text-gray-800 mb-6">${q.question}</h3>
                    
                    <div id="mcq-options">
                        ${options.map((opt, i) => `<div class="mcq-option" data-index="${i}" onclick="selectOption(this, '${String(opt).replace(/'/g, "\\'")}')">${opt}</div>`).join('')}
                    </div>

                    <!-- INICIO: MODIFICADO (Orden de botones) -->
                    <div class="mt-6 flex justify-between items-center">
                        <div class="flex flex-wrap gap-4">
                            <button id="edit-mcq-btn" class="text-sm text-gray-600 font-semibold flex items-center hover:underline">
                                <svg data-lucide="pencil" class="w-4 h-4 mr-1"></svg> Editar
                            </button>
                            <button id="anki-plus-btn" class="text-sm text-blue-600 font-semibold flex items-center hover:underline">
                                <svg data-lucide="plus-square" class="w-4 h-4 mr-1"></svg> Crear Flashcard
                            </button>
                            <button id="hint-btn" class="text-sm text-yellow-600 font-semibold flex items-center hover:underline">
                                <svg data-lucide="lightbulb" class="w-4 h-4 mr-1"></svg> Pedir Pista
                            </button>
                            <!-- NUEVO BOTÓN DE VERIFICACIÓN -->
                            <button id="verify-ai-btn" class="text-sm text-indigo-600 font-semibold flex items-center hover:underline" style="display: none;">
                                <svg data-lucide="shield-check" class="w-4 h-4 mr-1"></svg>
                                Doble Check IA
                                <div class="loader w-4 h-4 ml-2 border-2 border-indigo-200 border-t-indigo-600" style="display: none; animation: spin 1s linear infinite;"></div>
                            </button>
                        </div>
                        <button id="next-q-btn" class="px-6 py-2 bg-gray-200 text-gray-400 font-bold rounded cursor-not-allowed" disabled>Siguiente</button>
                    </div>
                    <!-- FIN: MODIFICADO -->
                    
                    <div id="hint-box" class="hint-box"></div>
                    
                    <!-- INICIO: MODIFICADO (Se usa el acordeón de Modo Inicial) -->
                    ${justificationHtml}
                    <!-- FIN: MODIFICADO -->

                    <div id="flashcard-feedback" class="flashcard-feedback"></div>
                </div>
            `;
            
            // --- CORRECCIÓN: Restaurando el bloque de listeners ---
            
            // Listener para Editar
            document.getElementById('edit-mcq-btn').onclick = () => openEditMcqModal(q);
            
            // Listener para Pista
            document.getElementById('hint-btn').onclick = () => getHint(q);
            
            // Listener para Crear Flashcard
            document.getElementById('anki-plus-btn').onclick = () => createFlashcardManually(q);
            
            // Listener para Siguiente
            document.getElementById('next-q-btn').onclick = () => {
                currentQuestionIndex++;
                renderQuestion();
            };

            // Listener para Doble Check (el que agregamos)
            const verifyBtn = document.getElementById('verify-ai-btn');
            // No mostramos el botón si la pregunta ya fue verificada en el pasado
            if (q.isVerified) {
                verifyBtn.style.display = 'none';
            } else {
                // El botón se hará visible en checkAnswer()
                verifyBtn.onclick = () => verifyAnswerWithAI(q, verifyBtn);
            }
            // --- FIN DE LA CORRECCIÓN ---

            // --- INICIO: NUEVO (Listeners Modo Inicial) ---
            if (currentPracticeMode === 'inicial') {
                const justBtn = document.getElementById('justification-btn');
                const justContent = document.getElementById('justification-content');
                if(justBtn) justBtn.onclick = () => toggleAccordion(justBtn, justContent);
                
                const genLink = document.getElementById('generate-justification-link');
                if(genLink) genLink.onclick = async (e) => {
                    e.preventDefault();
                    justContent.innerHTML = '<div class="loader w-4 h-4"></div>';
                    const newJustification = await getJustificationFromAI(q);
                    q.justification = newJustification; // Cache local
                    justContent.innerHTML = newJustification;
                    // Actualizar en BBDD (sin esperar)
                    updateDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq', q.id), { justification: newJustification });
                };
            }
            // --- FIN: NUEVO ---
            
            window.selectOption = (el, text) => checkAnswer(el, text, q);
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        async function getHint(questionData) {
            const box = document.getElementById('hint-box');
            box.style.display = 'block';
            box.textContent = "Generando pista...";
            const prompt = `Dame una pista corta para esta pregunta sin dar la respuesta: "${questionData.question}". Opciones: ${questionData.options.join(',')}`;
            const hint = await callGeminiAPI(prompt, false);
            box.textContent = "💡 Pista: " + hint;
        }

        // --- INICIO: NUEVA Función para generar justificación (Modo Inicial) ---
        async function getJustificationFromAI(qData) {
             const prompt = `
                Contexto:
                Pregunta: "${qData.question}"
                Opciones: ${qData.options.join(", ")}
                Respuesta Correcta: ${qData.options[qData.correctIndex] || qData.correctAnswer}

                Tarea: Escribe una justificación clara y concisa (2-3 frases) explicando por qué esa es la respuesta correcta y, si es breve, por qué las otras son incorrectas.
            `;
            const justification = await callGeminiAPI(prompt, false);
            return justification;
        }
        // --- FIN: NUEVA Función ---


        async function checkAnswer(el, selectedText, qData) {
            document.querySelectorAll('.mcq-option').forEach(o => {
                o.style.pointerEvents = 'none';
                // --- NUEVO: Añadir clase 'selected' para la lógica de recoloreado ---
                if (o === el) o.classList.add('selected');
            });
            
            // --- INICIO: Lógica de corrección MODIFICADA (Paquete 1) ---
            const selectedIndex = parseInt(el.dataset.index, 10);
            let isCorrect;
            let correctIndex;

            if (qData.correctIndex !== undefined) {
                // Nueva lógica (basada en índice)
                isCorrect = (selectedIndex === qData.correctIndex);
                correctIndex = qData.correctIndex;
            } else {
                // Lógica antigua (fallback para datos viejos)
                isCorrect = selectedText.trim() === String(qData.correctAnswer).trim();
                // Intentar adivinar el índice para colorear
                correctIndex = qData.options.findIndex(opt => String(opt).trim() === String(qData.correctAnswer).trim());
            }
            
            if (isCorrect) {
                el.classList.add('correct');
                currentQuizCorrect++;
                if (qData.status !== 'mastered') {
                    await updateDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq', qData.id), { status: 'mastered' });
                    qData.status = 'mastered';
                }
            } else {
                el.classList.add('incorrect');
                currentQuizWrong++;
                
                // Mostrar la correcta (si la encontramos)
                if (correctIndex > -1) {
                     document.querySelector(`.mcq-option[data-index="${correctIndex}"]`).classList.add('correct');
                }
                
                // --- MODIFICADO: Ya no se abre la flashcard automáticamente (Paquete 1) ---
                // if (!isFlashcardCreated) {
                //    isFlashcardCreated = true;
                //    await createFlashcardManually(qData, true); // true = es por error
                // }
            }
            // --- FIN: Lógica de corrección MODIFICADA ---

            // Mostrar la justificación (si está en modo inicial)
            const justBtn = document.getElementById('justification-btn');
            if (justBtn && justBtn.getAttribute('aria-expanded') === 'false') {
                 toggleAccordion(justBtn, document.getElementById('justification-content'));
            }

            const nextBtn = document.getElementById('next-q-btn');
            nextBtn.disabled = false;
            nextBtn.classList.remove('bg-gray-200', 'text-gray-400', 'cursor-not-allowed');
            nextBtn.classList.add('bg-blue-600', 'text-white', 'hover:bg-blue-700');
            
            // --- NUEVO: Mostrar el botón de "Doble Check" ---
            const verifyBtn = document.getElementById('verify-ai-btn');
            // Solo lo mostramos si la pregunta NO ha sido verificada antes
            if (verifyBtn && !qData.isVerified) {
                verifyBtn.style.display = 'flex';
            }
            // --- FIN NUEVO ---
        }
        
        // --- INICIO: NUEVA FUNCIÓN (Doble Check IA) ---
        async function verifyAnswerWithAI(qData, buttonEl) {
            const loader = buttonEl.querySelector('.loader');
            buttonEl.disabled = true;
            loader.style.display = 'block';

            // Un prompt genérico para que la IA re-evalúe la pregunta
            const genericPrompt = `
                ¡Doble Verificación de Experto!
                Por favor, analiza esta pregunta de examen y determina el índice de la respuesta correcta (de 0 a 3).
                Usa el contexto de la teoría si es necesario.

                --- Contexto de Teoría (para ayudarte) ---
                ${document.getElementById('theory').value.substring(0, 5000)}
                --- Fin de Teoría ---

                --- Pregunta a Analizar ---
                Pregunta: "${qData.question}"
                Opciones:
                0: "${qData.options[0]}"
                1: "${qData.options[1]}"
                2: "${qData.options[2]}"
                3: "${qData.options[3]}"

                Considerando la pregunta (que puede pedir la INCORRECTA), ¿cuál es el índice de la opción que se debe marcar?
                Responde SOLO con el número del índice correcto. Por ejemplo: 2
            `;

            try {
                const aiResponse = await callGeminiAPI(genericPrompt, false);
                const newCorrectIndex = parseInt(aiResponse.trim(), 10);

                if (isNaN(newCorrectIndex) || newCorrectIndex < 0 || newCorrectIndex > 3) {
                    throw new Error(`La IA devolvió una respuesta no válida: "${aiResponse}"`);
                }

                const docRef = doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq', qData.id);
                
                if (newCorrectIndex === qData.correctIndex) {
                    // La IA confirma la respuesta, solo marcamos como verificado
                    await updateDoc(docRef, { isVerified: true });
                    showError("¡Verificado! La IA confirma que la respuesta guardada es correcta.", false);
                } else {
                    // ¡Error encontrado! Actualizamos el índice Y marcamos como verificado
                    await updateDoc(docRef, { 
                        correctIndex: newCorrectIndex,
                        correctAnswer: qData.options[newCorrectIndex], // Actualizar también el texto
                        isVerified: true 
                    });
                    
                    // Actualizar caché local para esta sesión
                    qData.correctIndex = newCorrectIndex;
                    qData.isVerified = true;
                    
                    showError("¡Corrección Aplicada! La IA detectó un error y la respuesta ha sido actualizada en la base de datos.", false);
                    
                    // Volver a colorear las opciones con la nueva respuesta correcta
                    document.querySelectorAll('.mcq-option').forEach(opt => {
                        opt.classList.remove('correct', 'incorrect');
                        const optIndex = parseInt(opt.dataset.index, 10);
                        if (optIndex === newCorrectIndex) {
                            opt.classList.add('correct');
                        }
                        // Si la opción seleccionada no es la nueva correcta, marcarla como incorrecta
                        if (opt.classList.contains('selected') && optIndex !== newCorrectIndex) {
                             opt.classList.add('incorrect');
                        }
                    });
                }

                buttonEl.style.display = 'none'; // Ocultar después de usar

            } catch (err) {
                console.error("Error en Doble Check IA:", err);
                showError("Error al verificar con la IA. " + err.message);
                buttonEl.disabled = false;
            } finally {
                loader.style.display = 'none';
            }
        }
        // --- FIN: NUEVA FUNCIÓN ---
        
        // --- LÓGICA ANKI MEJORADA ---
        
        // Esta función ya no es necesaria, createFlashcardManually hace todo
        // async function createFlashcardFromWrongAnswer(qData) { ... }
        
        async function createFlashcardManually(qData, isFromError = false) {
            if (isFlashcardCreated && !isFromError) return; // No permitir crear dos veces
            isFlashcardCreated = true;
            
             const cardData = {
                id: '', // Vacío para CREAR
                subject: currentSubject,
                question: qData.question,
                answer: `<b>Respuesta Correcta:</b> ${qData.correctAnswer}<br><br><b>Justificación:</b> ${qData.justification || "Sin justificación."}`,
                imageUrl: '',
                unit: qData.unit || "Choice",
                topic: qData.topic || "Sin Clasificar"
            };
            
            openEditModal(cardData, true); // true = es una nueva tarjeta

            const feedback = document.getElementById('flashcard-feedback');
            feedback.textContent = isFromError ? '¡Error! Abriendo editor de flashcard para repasar...' : 'Editor de Flashcard abierto...';
            feedback.style.display = 'block';
            if (!isFromError) document.getElementById('anki-plus-btn').style.display = 'none';
        }
        
        // --- SISTEMA DE REPASO (SRS - ANKI) ---
        
        function startAnkiSession(cards, container, onFinish) {
            let currentCardIndex = 0;
            const originalCards = [...cards];

            function renderNextCard() {
                container.innerHTML = '';
                if (currentCardIndex >= originalCards.length) {
                    container.innerHTML = '<p class="text-green-600 font-bold p-4 text-center">¡Sesión completada!</p>';
                    if (onFinish) onFinish();
                    return;
                }
                
                const card = originalCards[currentCardIndex];
                const div = document.createElement('div');
                div.className = 'qa-card border border-blue-300 shadow-lg';
                
                let imageHtml = card.imageUrl ? `<img src="${card.imageUrl}" alt="Imagen de repaso" class="mt-2 rounded-md max-h-60 object-contain">` : '';

                div.innerHTML = `
                    <p class="font-bold text-gray-800 mb-2">${card.question}</p>
                    ${imageHtml}
                    <div class="answer hidden mt-2 p-3 bg-gray-50 rounded border-l-4 border-blue-500 text-sm text-gray-700">${card.answer}</div>
                    <div class="controls mt-3 flex justify-between items-center">
                        <button class="show-ans-btn text-blue-600 text-sm font-bold">Mostrar Respuesta</button>
                        <div class="rating-btns hidden gap-2">
                            <button class="px-2 py-1 bg-red-100 text-red-700 rounded text-xs font-bold" data-rate="hard">Difícil (Reset)</button>
                            <button class="px-2 py-1 bg-blue-100 text-blue-700 rounded text-xs font-bold" data-rate="good">Bien</button>
                            <button class="px-2 py-1 bg-green-100 text-green-700 rounded text-xs font-bold" data-rate="easy">Fácil</button>
                        </div>
                    </div>
                    <button class="edit-qa-btn !top-auto bottom-3 right-3">
                        <svg data-lucide="pencil" class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/><path d="m15 5 4 4"/></svg>
                    </button>
                `;
                
                const ansDiv = div.querySelector('.answer');
                const controlsDiv = div.querySelector('.rating-btns');
                const showBtn = div.querySelector('.show-ans-btn');
                
                showBtn.onclick = () => { ansDiv.classList.remove('hidden'); controlsDiv.classList.remove('hidden'); showBtn.classList.add('hidden'); };
                
                div.querySelectorAll('[data-rate]').forEach(btn => {
                    btn.onclick = async () => {
                        await processSRS(card, btn.dataset.rate);
                        currentCardIndex++;
                        renderNextCard();
                    };
                });
                
                div.querySelector('.edit-qa-btn').onclick = (e) => {
                    e.stopPropagation();
                    openEditModal(card);
                };
                
                container.appendChild(div);
                if (typeof lucide !== 'undefined') lucide.createIcons();
            }
            
            renderNextCard();
        }

        function renderReviewCards(cards, isGlobal) {
            els.reviewList.innerHTML = '';
            if (cards.length === 0) {
                els.reviewList.innerHTML = '<div class="text-center py-10 text-green-600 font-bold bg-green-50 rounded">¡Todo al día!</div>';
                return;
            }
            
            const groupKey = isGlobal ? 'subject' : 'topic';
            const groupedCards = cards.reduce((acc, card) => {
                const name = card[groupKey] || (isGlobal ? "Sin Materia" : "Sin Clasificar");
                if (!acc[name]) acc[name] = [];
                acc[name].push(card);
                return acc;
            }, {});
            
            for (const groupName in groupedCards) {
                const groupCards = groupedCards[groupName];
                const btn = document.createElement('button');
                btn.className = 'accordion-btn';
                btn.innerHTML = `
                    <span>${groupName} (${groupCards.length} tarjetas)</span>
                    <span class="toggle-icon" data-lucide="chevron-down"></span>
                `;
                
                const content = document.createElement('div');
                content.className = 'accordion-content p-4';
                
                const practiceBtn = document.createElement('button');
                practiceBtn.className = 'px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg text-sm hover:bg-blue-700';
                practiceBtn.textContent = 'Empezar Repaso';
                practiceBtn.onclick = (e) => {
                    e.stopPropagation();
                    startAnkiSession(groupCards, content, () => {
                        loadReviewData(currentSubject);
                    });
                };
                content.appendChild(practiceBtn);

                // btn.onclick = (e) => toggleAccordion(e); // MODIFICADO
                // --- INICIO CORRECCIÓN 2 ---
                // Le pasamos el botón y el contenido directamente.
                btn.onclick = () => toggleAccordion(btn, content); 
                // --- FIN CORRECCIÓN 2 ---

                els.reviewList.appendChild(btn);
                els.reviewList.appendChild(content);
            }
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }

        async function processSRS(card, rating) {
            let nextDate = new Date();
            let nextStep = card.reviewStep || 0;
            
            if (rating === 'hard') {
                nextStep = 0;
                nextDate.setMinutes(nextDate.getMinutes() + 10);
            } else {
                const days = rating === 'easy' ? (nextStep === 0 ? 3 : nextStep * 2.5) : (nextStep === 0 ? 1 : nextStep * 1.5); 
                nextDate.setDate(nextDate.getDate() + Math.ceil(days));
                nextStep++;
            }
            
            const subject = card.subject || currentSubject;
            if (!subject) {
                 console.error("Error: No se pudo determinar la materia de la tarjeta.", card);
                 return;
            }
            
            await updateDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', subject, 'saved_questions', card.id), {
                reviewStep: nextStep,
                nextReviewDate: nextDate
            });
        }
        
        // --- MODAL DE EDICIÓN DE FLASHCARD (MODIFICADO) ---
        function openEditModal(card, isNew = false) {
            if(!card) return;
            
            els.editQaTitle.textContent = isNew ? "Crear Nueva Flashcard" : "Editar Flashcard";
            els.editQaId.value = card.id || ''; // Vacío si es nueva
            els.editQaSubject.value = card.subject || currentSubject; 
            els.editQaQuestion.value = card.question || '';
            els.editQaAnswer.value = card.answer || '';
            els.editQaImage.value = card.imageUrl || '';
            els.editQaUnit.value = card.unit || 'General'; // Campos ocultos
            els.editQaTopic.value = card.topic || 'General'; // Campos ocultos
            
            els.editQaModal.style.display = 'flex';
        }
        
        async function saveEditQa() {
            const id = els.editQaId.value;
            const subject = els.editQaSubject.value; 
            
            if (!subject || subject === 'all') {
                showError("Error: No se pudo determinar la materia para guardar.");
                return;
            };
            
            // Recoger todos los datos del modal
            const data = {
                question: els.editQaQuestion.value,
                answer: els.editQaAnswer.value,
                imageUrl: els.editQaImage.value,
                unit: els.editQaUnit.value,
                topic: els.editQaTopic.value,
            };
            
            try {
                if (id) {
                    // --- EDITAR (Lógica existente) ---
                    const docRef = doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', subject, 'saved_questions', id);
                    await updateDoc(docRef, data);
                } else {
                    // --- CREAR (NUEVA Lógica) ---
                    const collectionRef = collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', subject, 'saved_questions');
                    await addDoc(collectionRef, {
                        ...data,
                        reviewStep: 0,
                        nextReviewDate: serverTimestamp(),
                        createdAt: serverTimestamp()
                    });
                }
                
                els.editQaModal.style.display = 'none';
                
                // Recargar la vista actual para ver los cambios
                if (currentSubject === 'all') {
                    if (currentTab === 'review') loadReviewData('all');
                    if (currentTab === 'roadmap') loadRoadmapData('all');
                } else {
                    if (currentTab === 'review') loadReviewData(currentSubject);
                    if (currentTab === 'roadmap') loadRoadmapData(currentSubject);
                    if (currentTab === 'topics') loadTopicManager();
                }
                
                // Resetear el feedback en la pestaña choice
                const feedback = document.getElementById('flashcard-feedback');
                if (feedback) feedback.style.display = 'none';
                
            } catch (e) {
                console.error("Error al guardar flashcard:", e);
                showError("No se pudo guardar la tarjeta.");
            }
        }

        // --- INICIO: NUEVAS Funciones para Modal Edición MCQ (Paquete 2) ---
        function openEditMcqModal(qData) {
            els.editMcqId.value = qData.id;
            els.editMcqQuestion.value = qData.question;
            els.editMcqJustification.value = qData.justification || '';
            els.editMcqOptionsContainer.innerHTML = ''; // Limpiar opciones

            let correctIndex = -1;
            // Determinar el índice correcto (compatible con datos nuevos y viejos)
            if (qData.correctIndex !== undefined) {
                correctIndex = qData.correctIndex;
            } else {
                correctIndex = qData.options.findIndex(opt => String(opt).trim() === String(qData.correctAnswer).trim());
            }

            qData.options.forEach((option, index) => {
                const isChecked = (index === correctIndex);
                const optionEl = document.createElement('div');
                optionEl.className = 'flex items-center gap-2';
                optionEl.innerHTML = `
                    <input type="radio" name="correct-option" id="edit-option-${index}" value="${index}" ${isChecked ? 'checked' : ''} class="h-4 w-4 text-blue-600">
                    <input type="text" value="${option}" class="edit-mcq-option-input w-full p-2 border border-gray-300 rounded">
                `;
                els.editMcqOptionsContainer.appendChild(optionEl);
            });

            els.editMcqModal.style.display = 'flex';
        }

        async function saveEditMcq() {
            const id = els.editMcqId.value;
            const newQuestion = els.editMcqQuestion.value;
            const newJustification = els.editMcqJustification.value;
            
            const newOptions = [];
            document.querySelectorAll('.edit-mcq-option-input').forEach(input => {
                newOptions.push(input.value);
            });

            const newCorrectIndex = parseInt(document.querySelector('input[name="correct-option"]:checked').value, 10);

            if (!id || !newQuestion || newOptions.length < 2 || newCorrectIndex < 0) {
                showError("Error: Faltan datos para guardar la pregunta.");
                return;
            }
            
            const updatedData = {
                question: newQuestion,
                options: newOptions,
                justification: newJustification,
                correctIndex: newCorrectIndex,
                correctAnswer: newOptions[newCorrectIndex], // (Opcional, pero bueno para fallback)
                isVerified: true // --- NUEVO: Editar también marca como verificado ---
            };

            try {
                const docRef = doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq', id);
                await updateDoc(docRef, updatedData);
                
                // Actualizar caché local
                const cacheIndex = cachedMcqs.findIndex(q => q.id === id);
                if (cacheIndex > -1) {
                    cachedMcqs[cacheIndex] = { ...cachedMcqs[cacheIndex], ...updatedData };
                }
                const practiceIndex = currentPracticeQuestions.findIndex(q => q.id === id);
                if (practiceIndex > -1) {
                    currentPracticeQuestions[practiceIndex] = { ...currentPracticeQuestions[practiceIndex], ...updatedData };
                }
                
                els.editMcqModal.style.display = 'none';
                renderQuestion(); // Volver a renderizar la pregunta actual con los datos nuevos
                showError("Pregunta actualizada con éxito.", false);

            } catch (e) {
                console.error("Error al guardar MCQ:", e);
                showError("No se pudo guardar la pregunta.");
            }
        }
        // --- FIN: NUEVAS Funciones para Modal Edición MCQ ---


        // --- HOJA DE RUTA (MEJORADA) ---
        function renderRoadmapAccordions(groupedByDay, isGlobal) {
            els.roadmapList.innerHTML = ''; // Limpiar
            for (const dateStr in groupedByDay) {
                const dayCards = groupedByDay[dateStr];
                const btn = document.createElement('button');
                btn.className = 'accordion-btn';
                btn.innerHTML = `
                    <span>${dateStr} (${dayCards.length} tarjetas)</span>
                    <div class="flex items-center gap-2">
                        <button class="practice-day-btn px-3 py-1 bg-blue-100 text-blue-700 font-semibold rounded-lg text-xs hover:bg-blue-200">Practicar este día</button>
                        <span class="toggle-icon" data-lucide="chevron-down"></span>
                    </div>
                `;
                
                const content = document.createElement('div');
                content.className = 'accordion-content p-4 space-y-1';
                
                // Si es global, mostrar la materia
                content.innerHTML = dayCards.map(c => 
                    `<p class="text-sm text-gray-600 border-b pb-1">
                        ${isGlobal ? `<span class="font-bold text-purple-700">[${c.subject}]</span>` : ''}
                        ${c.question.substring(0, 70)}...
                    </p>`
                ).join('');

                btn.querySelector('.practice-day-btn').onclick = (e) => {
                    e.stopPropagation();
                    els.roadmapList.style.display = 'none'; // Ocultar lista
                    els.roadmapPractice.style.display = 'block'; // Mostrar sesión
                    startAnkiSession(dayCards, els.roadmapPractice, () => {
                        // Al terminar, volver a la lista
                        els.roadmapPractice.style.display = 'none';
                        els.roadmapList.style.display = 'block';
                        loadRoadmapData(currentSubject); // Recargar
                    });
                };

                // btn.onclick = (e) => toggleAccordion(e); // MODIFICADO: Usar helper
                // --- INICIO CORRECCIÓN 2 ---
                // Le pasamos el botón y el contenido, y chequeamos clicks internos.
                btn.onclick = (e) => {
                    if (e.target.closest('.practice-day-btn')) return;
                    toggleAccordion(btn, content);
                };
                // --- FIN CORRECCIÓN 2 ---
                
                els.roadmapList.appendChild(btn);
                els.roadmapList.appendChild(content);
            }
            if (typeof lucide !== 'undefined') lucide.createIcons();
        }
        
        // --- PESTAÑA "ADMINISTRAR TEMAS" (MEJORADA) ---
        
        async function loadTopicManager() {
            if (!currentSubject || currentSubject === 'all') {
                 els.topicManagerList.innerHTML = '<p class="text-gray-400 text-center py-10">Selecciona una materia específica.</p>';
                 return;
            }
            els.topicManagerLoader.style.display = 'block';
            els.topicManagerList.innerHTML = '';
            
            try {
                const mcqSnap = await getDocs(query(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq')));
                const ankiSnap = await getDocs(query(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_questions')));
                
                const allQuestions = [];
                mcqSnap.forEach(d => allQuestions.push({ id: d.id, type: 'mcq', ...d.data() }));
                ankiSnap.forEach(d => allQuestions.push({ id: d.id, type: 'anki', ...d.data() }));
                
                const groupedByTopic = allQuestions.reduce((acc, q) => {
                    const topic = q.topic || "Sin Clasificar";
                    if (!acc[topic]) acc[topic] = [];
                    acc[topic].push(q);
                    return acc;
                }, {});
                
                els.topicManagerLoader.style.display = 'none';
                
                // --- NUEVO: Nivel 1 (Global) ---
                const globalDiv = document.createElement('div');
                globalDiv.className = 'border rounded-lg mb-2';
                globalDiv.innerHTML = `
                    <button class="accordion-btn !bg-blue-50 !border-blue-200">
                        <span class="font-bold text-blue-700">[+] Ver Todas las Preguntas (${allQuestions.length})</span>
                        <span class="toggle-icon" data-lucide="chevron-down"></span>
                    </button>
                    <div class="accordion-content p-4 space-y-2">
                        ${allQuestions.map(q => renderQuestionManagerRow(q)).join('')}
                    </div>
                `;
                // globalDiv.querySelector('button').onclick = toggleAccordion; // OLD
                // --- INICIO CORRECCIÓN 2 ---
                const globalBtn = globalDiv.querySelector('button');
                const globalContent = globalDiv.querySelector('.accordion-content');
                globalBtn.onclick = () => toggleAccordion(globalBtn, globalContent);
                // --- FIN CORRECCIÓN 2 ---
                els.topicManagerList.appendChild(globalDiv);
                
                // --- Nivel 2 (Por Tema) ---
                const sortedTopics = Object.keys(groupedByTopic).sort();
                sortedTopics.forEach(topicName => {
                    const topicQuestions = groupedByTopic[topicName];
                    const div = document.createElement('div');
                    div.className = 'border rounded-lg mb-2';
                    div.innerHTML = `
                        <!-- MODIFICADO: Este botón ahora también es un acordeón -->
                        <button class="accordion-btn !bg-white !border-none !mb-0">
                            <span class="flex items-center gap-2">
                                <input type="checkbox" class="topic-select-box" data-topic-name="${topicName.replace(/"/g, "'")}">
                                <span class="font-bold">${topicName}</span>
                                <span class="text-sm text-gray-500">(${topicQuestions.length} preguntas)</span>
                            </span>
                            <div class="flex items-center gap-2">
                                <button class="rename-topic-btn px-3 py-1 bg-blue-100 text-blue-700 font-semibold rounded-lg text-xs hover:bg-blue-200">Renombrar</button>
                                <span class="toggle-icon" data-lucide="chevron-down"></span>
                            </div>
                        </button>
                        <div class="accordion-content p-4 space-y-2">
                            ${topicQuestions.map(q => renderQuestionManagerRow(q)).join('')}
                        </div>
                    `;
                    
                    // --- MODIFICADO: El onclick principal ahora es el toggle ---
                    const topicBtn = div.querySelector('.accordion-btn');
                    const topicContent = div.querySelector('.accordion-content');
                    topicBtn.onclick = (e) => {
                        // if (e.target.closest('input') || e.target.closest('.rename-topic-btn')) return; // OLD - BUGGY
                        // --- INICIO CORRECCIÓN 3 ---
                        // Solo evitamos el toggle si se hace click en el botón renombrar.
                        // El click en el checkbox AHORA SÍ abrirá el acordeón.
                        if (e.target.closest('.rename-topic-btn')) return;
                        // --- FIN CORRECCIÓN 3 ---
                        toggleAccordion(topicBtn, topicContent);
                    };
                    
                    div.querySelector('.rename-topic-btn').onclick = (e) => {
                        e.stopPropagation();
                        renombrarTema(topicName);
                    };
                    els.topicManagerList.appendChild(div);
                });
                
                // Listeners para todos los checkboxes y botones de editar/borrar
                els.topicManagerList.querySelectorAll('input[type="checkbox"]').forEach(box => {
                    box.onchange = updateTopicManagerControls;
                });
                els.topicManagerList.querySelectorAll('.edit-qa-inline-btn').forEach(btn => {
                    btn.onclick = async (e) => {
                        e.stopPropagation();
                        const cardId = e.target.dataset.id;
                        const card = (await getDoc(doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_questions', cardId))).data();
                        openEditModal({id: cardId, subject: currentSubject, ...card});
                    }
                });
                // NUEVO: Listener para botones de eliminar
                els.topicManagerList.querySelectorAll('.delete-question-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const { docId, type } = e.currentTarget.dataset;
                        handleDeleteQuestion(docId, type);
                    }
                });
                
                if (typeof lucide !== 'undefined') lucide.createIcons();

            } catch (e) {
                console.error("Error cargando Topic Manager:", e);
                els.topicManagerLoader.style.display = 'none';
                els.topicManagerList.innerHTML = `<p class="text-red-500">Error al cargar temas.</p>`;
            }
        }
        
        // --- MODIFICADO: renderQuestionManagerRow (con botón borrar) ---
        function renderQuestionManagerRow(q) {
             return `
                <div class="flex items-center gap-2 p-2 border-b">
                    <input type="checkbox" class="question-select-box" data-doc-id="${q.id}" data-type="${q.type}">
                    <p class="text-sm flex-1">
                        <span class="font-semibold ${q.type === 'mcq' ? 'text-purple-700' : 'text-blue-700'}">[${q.type.toUpperCase()}]</span>
                        ${q.question}
                        ${q.type === 'anki' ? `<button class="edit-qa-inline-btn text-xs text-blue-500 hover:underline ml-2" data-id="${q.id}">Editar</button>` : ''}
                    </p>
                    <!-- NUEVO: Botón de Borrar -->
                    <button class="delete-question-btn" data-doc-id="${q.id}" data-type="${q.type}">
                        <svg data-lucide="trash-2" class="w-3 h-3" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>
                    </button>
                </div>
            `;
        }
        
        // --- NUEVO: Función para mostrar modal de confirmación de borrado ---
        function showConfirmModal(message, onConfirm) {
            els.confirmMsg.textContent = message;
            els.confirmModal.style.display = 'flex';
            
            // Remover listener anterior y agregar uno nuevo (one-shot)
            els.confirmYes.replaceWith(els.confirmYes.cloneNode(true));
            els.confirmYes = document.getElementById('confirm-yes'); // Re-seleccionar
            
            els.confirmYes.onclick = () => {
                onConfirm();
                els.confirmModal.style.display = 'none';
            };
        }
        
        // --- NUEVO: Función para manejar el borrado de preguntas ---
        async function handleDeleteQuestion(docId, type) {
            if (!currentSubject || !docId || !type) return;
            
            const collectionName = type === 'mcq' ? 'saved_mcq' : 'saved_questions';
            
            showConfirmModal("¿Estás seguro de que quieres eliminar esta pregunta? Esta acción no se puede deshacer.", async () => {
                try {
                    const docRef = doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, collectionName, docId);
                    await deleteDoc(docRef);
                    showError("Pregunta eliminada.", false);
                    loadTopicManager(); // Recargar la vista
                    loadChoiceTopics(); // Recargar temas de choice por si acaso
                } catch (e) {
                    console.error("Error al eliminar pregunta:", e);
                    showError("No se pudo eliminar la pregunta.");
                }
            });
        }
        
        // --- CORRECCIÓN: Función toggleAccordion simplificada y robusta ---
        // function toggleAccordion(e) { // OLD
            // const btn = e.target.closest('.accordion-btn');
            // if (!btn) {
            //      return;
            // }
            // const content = btn.nextElementSibling;
            // if (!content) {
            //     console.error("Error: no se encontró .accordion-content después del botón.");
            //     return; 
            // }
            
            // const isExpanded = btn.getAttribute('aria-expanded') === 'true';
            // btn.setAttribute('aria-expanded', String(!isExpanded));
        // } // OLD
        
        // La función ahora recibe el botón y el contenido directamente.
        function toggleAccordion(btn, content) { // <-- AÑADIDO: Definición de la función
            // --- INICIO CORRECCIÓN 3 ---
            // Asegurarnos de que el ícono (si existe) también rote
            const icon = btn.querySelector('.toggle-icon, .lucide-chevron-down');
            // --- FIN CORRECCIÓN 3 ---
            
            const isExpanded = btn.getAttribute('aria-expanded') === 'true';
            btn.setAttribute('aria-expanded', String(!isExpanded));
            content.classList.toggle('open');
            
            // --- INICIO CORRECCIÓN 3 ---
            // Manejar la rotación del ícono si no es por CSS puro (útil para lucide)
            if (icon) {
                 icon.style.transform = isExpanded ? 'rotate(0deg)' : 'rotate(180deg)';
            }
            // --- FIN CORRECCIÓN 3 ---
        } // <-- Esta llave ahora cierra la función 'toggleAccordion'
        // --- FIN CORRECCIÓN 2 ---
        
        function updateTopicManagerControls() {
            const selectedTopics = els.topicManagerList.querySelectorAll('.topic-select-box:checked').length;
            const selectedQuestions = els.topicManagerList.querySelectorAll('.question-select-box:checked').length;
            
            els.mergeTopicsBtn.disabled = selectedTopics < 2;
            els.createSubtopicBtn.disabled = selectedQuestions === 0;
        }

        async function renombrarTema(oldTopicName) {
            const newTopicName = prompt(`Renombrar tema:\n"${oldTopicName}"\n\nNuevo nombre:`);
            if (!newTopicName || newTopicName.trim() === '' || newTopicName === oldTopicName) return;
            
            await updateTopicNames([oldTopicName], newTopicName);
            loadTopicManager();
        }

        async function mergeSelectedTopics() {
            const selectedTopics = Array.from(els.topicManagerList.querySelectorAll('.topic-select-box:checked'))
                                       .map(box => box.dataset.topicName);
            if (selectedTopics.length < 2) return;
            
            const newTopicName = prompt(`Fusionar ${selectedTopics.length} temas.\n\nNuevo nombre para el tema fusionado:`);
            if (!newTopicName || newTopicName.trim() === '') return;
            
            await updateTopicNames(selectedTopics, newTopicName);
            loadTopicManager();
        }
        
        async function createSubtopicFromSelected() {
            const selectedQuestions = Array.from(els.topicManagerList.querySelectorAll('.question-select-box:checked'));
            if (selectedQuestions.length === 0) return;
            
            const newSubtopicName = prompt(`Crear subtema con ${selectedQuestions.length} preguntas.\n\nNombre del nuevo subtema:`);
            if (!newSubtopicName || newSubtopicName.trim() === '') return;
            
            try {
                const batch = writeBatch(db);
                selectedQuestions.forEach(box => {
                    const { docId, type } = box.dataset;
                    const collectionName = type === 'mcq' ? 'saved_mcq' : 'saved_questions';
                    const docRef = doc(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, collectionName, docId);
                    batch.update(docRef, { topic: newSubtopicName });
                });
                await batch.commit();
                showError("Subtema creado con éxito.", false);
                loadTopicManager();
            } catch (e) {
                console.error("Error creando subtema:", e);
                showError("Error al crear el subtema.");
            }
        }

        async function updateTopicNames(oldNames, newName) {
            try {
                const batch = writeBatch(db);
                
                const mcqQuery = query(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_mcq'), where('topic', 'in', oldNames));
                const mcqSnap = await getDocs(mcqQuery);
                mcqSnap.forEach(d => batch.update(d.ref, { topic: newName }));
                
                const ankiQuery = query(collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_questions'), where('topic', 'in', oldNames));
                const ankiSnap = await getDocs(ankiQuery);
                ankiSnap.forEach(d => batch.update(d.ref, { topic: newName }));
                
                await batch.commit();
                showError("Temas actualizados con éxito.", false);
            } catch (e) {
                console.error("Error actualizando temas:", e);
                showError("Error al actualizar los temas.");
            }
        }
        
        // --- MODOS ORALES (Estructura de Temas Mejorada) ---
        
        async function loadSyllabusBrowser() {
             if (!currentSubject || currentSubject === 'all') {
                 els.syllabusBrowser.innerHTML = '<p class="text-gray-400 text-center py-10">Selecciona una materia específica.</p>';
                 return;
            }
            const container = document.getElementById('syllabus-browser');
            container.innerHTML = `<div class="loader mx-auto"></div><p class="text-center text-gray-500">Analizando Syllabus, Teoría y Choices para crear la estructura...</p>`;
            try {
                const syllabus = document.getElementById('syllabus').value;
                const theory = document.getElementById('theory').value;
                const choiceRaw = els.choiceRaw.value;
                const fullContext = `--- PLAN DE ESTUDIO ---\n${syllabus}\n\n--- TEORÍA ---\n${theory}\n\n--- EXÁMENES CHOICE ---\n${choiceRaw}`;

                const structuredSyllabus = await parseSyllabusWithAI(fullContext);

                container.innerHTML = '';
                structuredSyllabus.forEach(unit => {
                    const div = document.createElement('div');
                    // --- INICIO: Corrección V15 (basado en V6) ---
                    // Añadimos la clase 'unit-toggle-btn' para el listener
                    div.innerHTML = `<button class="accordion-btn text-lg unit-toggle-btn">${unit.unit} <span class="toggle-icon" data-lucide="chevron-down"></span></button>`;
                    const topicsContainer = document.createElement('div');
                    topicsContainer.className = 'accordion-content';
                    
                    // Usamos un botón con data-attributes, como en V6, en lugar del alert()
                    topicsContainer.innerHTML = unit.topics.map(t => 
                        `<button class="syllabus-topic-btn" data-unit="${unit.unit.replace(/"/g, "'")}" data-topic="${t.replace(/"/g, "'")}">${t}</button>`
                    ).join('');
                    // --- FIN: Corrección V15 (basado en V6) ---
                    div.appendChild(topicsContainer);
                    container.appendChild(div);
                });
                
                // Ya no necesitamos este listener, usamos el global en setupListeners()
                // container.querySelectorAll('.accordion-btn').forEach(btn => {
                //    btn.onclick = () => btn.nextElementSibling.classList.toggle('open');
                // });
                
                // --- INICIO: Corrección ---
                // Nos aseguramos de renderizar los íconos de los acordeones
                if (typeof lucide !== 'undefined') { lucide.createIcons(); }
                // --- FIN: Corrección ---
            } catch (e) {
                console.error("Error al parsear syllabus con IA:", e);
                container.innerHTML = `<p class="text-red-500">Error al generar la estructura de temas: ${e.message}</p>`;
            }
        }
        
        async function parseSyllabusWithAI(fullMaterial) {
             const prompt = `
                Analiza todo el material de estudio (Plan de Estudio, Teoría y Exámenes) y genera una estructura de temas (Unidades y Temas).
                Material: ${fullMaterial.substring(0, 25000)}...
                Responde SOLO con un JSON Array: [{ "unit": "Nombre Unidad", "topics": ["Tema 1", "Tema 2", ...] }]
            `;
            let txt = await callGeminiAPI(prompt, true);
            return parseJsonFromAi(txt);
        }

        // --- INICIO: Lógica de Modo Estudio (traída de V6) ---
        
        /**
         * Se llama al seleccionar un tema en el Modo Estudio.
         */
        async function handleStudyTopicSelect(topicButton) {
            const topicName = topicButton.dataset.topic;
            const unitName = topicButton.dataset.unit;

            if (!topicName || !unitName) return;
            
            // Ocultar selección y mostrar loader
            els.syllabusBrowser.style.display = 'none';
            // Usamos el loader de la pestaña Admin Temas, ya que está disponible
            els.topicManagerLoader.style.display = 'block'; 
            const output = document.getElementById('study-output');
            output.innerHTML = '';

            const materials = {
                syllabus: document.getElementById('syllabus').value,
                theory: document.getElementById('theory').value,
                experiences: document.getElementById('experiences').value
            };
            
            if (!materials.theory && !materials.experiences) {
                 showError("El 'Modo Estudio' funciona mejor si cargas 'Teoría' y 'Experiencias' en la pestaña Material.");
            }

            try {
                const guideData = await generatePrioritizedStudyGuide(topicName, unitName, materials);
                renderStudyGuide(guideData, unitName);
            } catch (error) {
                console.error("Error al generar guía de estudio:", error);
                showError(`No se pudo generar la guía: ${error.message}`);
                output.innerHTML = `<p class="text-red-500">Error al generar la guía.</p>`;
            } finally {
                els.topicManagerLoader.style.display = 'none'; // Ocultar loader
            }
        }

        /**
         * Llama a la IA para crear la guía de estudio priorizada. (de V6)
         */
        async function generatePrioritizedStudyGuide(topicName, unitName, materials) {
            const systemPrompt = "Eres un Tutor Médico experto. El estudiante quiere estudiar un tema. Analiza su material (Teoría) y las preguntas de examen (Experiencias). Tu misión es crear una Guía de Estudio Priorizada en formato JSON. Identifica 5-7 subtemas clave. Para cada subtema, asigna una Importancia (Alta, Media, Baja) basándote en las Experiencias y la Teoría, justifica tu elección brevemente, y crea una 'pregunta clave' excelente para ese subtema.";
            
            const jsonSchema = {
                type: "OBJECT",
                properties: {
                    "topic": { "type": "STRING" },
                    "ai_summary": { "type": "STRING" },
                    "subtopics": {
                        "type": "ARRAY",
                        "items": {
                            "type": "OBJECT",
                            "properties": {
                                "subtopic_name": { "type": "STRING" },
                                "importance": { "type": "STRING" },
                                "justification": { "type": "STRING" },
                                "key_question": { "type": "STRING" }
                            },
                            "required": ["subtopic_name", "importance", "justification", "key_question"]
                        }
                    }
                },
                "required": ["topic", "ai_summary", "subtopics"]
            };

            const generationConfig = {
                responseMimeType: "application/json",
                responseSchema: jsonSchema
            };

            const userQuery = `
                Material del Estudiante:
                --- PLAN DE ESTUDIO (Contexto) ---
                ${materials.syllabus || "No proporcionado."}
                --- TEORÍA / APUNTES ---
                ${materials.theory || "No proporcionado."}
                --- EXPERIENCIAS DE EXÁMENES ---
                ${materials.experiences || "No proporcionado."}
                --- FIN DEL MATERIAL ---

                Tema a Estudiar: "${topicName}" (de la unidad: "${unitName}")

                Por favor, genera la Guía de Estudio Priorizada en JSON.
            `;
            
            // Usamos la firma completa de callGeminiAPI
            const resultText = await callGeminiAPI(userQuery, true, systemPrompt, generationConfig); 
            return JSON.parse(resultText);
        }

        /**
         * Renderiza la Guía de Estudio Priorizada en la UI. (de V6)
         */
        function renderStudyGuide(guideData, unitName) {
            const output = document.getElementById('study-output');
            output.innerHTML = ''; // Limpiar
            
            // Título y Resumen
            const title = document.createElement('h2');
            title.className = 'text-3xl font-bold text-gray-800 mb-4';
            title.textContent = `Guía de Estudio: ${guideData.topic}`;
            
            const summary = document.createElement('p');
            summary.className = 'guide-summary';
            summary.textContent = guideData.ai_summary;
            
            output.appendChild(title);
            output.appendChild(summary);

            // Renderizar cada subtema
            guideData.subtopics.forEach(subtopic => {
                const block = document.createElement('div');
                block.className = 'subtopic-block';

                // Importancia (para el badge)
                let importanceClass = 'importance-badge-baja'; // Default
                if (subtopic.importance.toLowerCase().includes('alta')) {
                    importanceClass = 'importance-badge-alta';
                } else if (subtopic.importance.toLowerCase().includes('media')) {
                    importanceClass = 'importance-badge-media';
                }

                block.innerHTML = `
                    <div class="subtopic-header">
                        <h4>${subtopic.subtopic_name}</h4>
                        <span class="importance-badge ${importanceClass}">${subtopic.importance}</span>
                    </div>
                    <div class="subtopic-body">
                        <p class="ai-justification">${subtopic.justification}</p>
                        
                        <div class="key-question-wrapper">
                            <!-- La pregunta clave se insertará aquí -->
                        </div>
                        
                        <div class="sub-question-container"></div>
                        <div class="sub-question-loader loader"></div>
                    </div>
                    
                    <button class="generate-more-btn" data-unit="${unitName}" data-topic="${guideData.topic}" data-subtopic="${subtopic.subtopic_name}">
                        <svg data-lucide="plus" class="w-4 h-4"></svg>
                        Generar más preguntas de este subtema
                    </button>
                `;
                
                // Generar y añadir la pregunta clave
                const keyQuestionWrapper = block.querySelector('.key-question-wrapper');
                const questionHTML = createQuestionItemHTML(subtopic.key_question, unitName, guideData.topic);
                keyQuestionWrapper.innerHTML = questionHTML;

                output.appendChild(block);
            });
            
            if (typeof lucide !== 'undefined') { lucide.createIcons(); }
        }

        /**
         * Genera más preguntas para un subtema específico. (de V6)
         */
        async function handleGenerateMoreQuestions(button) {
            const unitName = button.dataset.unit;
            const topicName = button.dataset.topic;
            const subtopicName = button.dataset.subtopic;
            const container = button.previousElementSibling.querySelector('.sub-question-container');
            const loader = button.previousElementSibling.querySelector('.sub-question-loader');
            
            if (!unitName || !topicName || !subtopicName || !container || !loader) {
                console.error("Faltan datos en el botón 'Generar Más'");
                return;
            }

            button.disabled = true;
            loader.style.display = 'block';

            const materials = {
                syllabus: document.getElementById('syllabus').value,
                theory: document.getElementById('theory').value,
                experiences: document.getElementById('experiences').value
            };

            const systemPrompt = "Eres un Tutor Médico. Genera 3 preguntas de examen oral, cortas y directas, sobre el siguiente subtema. No te repitas. Responde solo con la lista de preguntas, cada una en una nueva línea.";
            const userQuery = `
                Material del Estudiante:
                --- TEORÍA (Contexto) ---
                ${materials.theory || "No proporcionado."}
                --- EXPERIENCIAS (Contexto) ---
                ${materials.experiences || "No proporcionado."}
                --- FIN DEL MATERIAL ---

                Tema Principal: "${topicName}"
                Subtema Específico: "${subtopicName}"

                Genera 3 preguntas solo sobre el subtema específico.
            `;

            try {
                const resultText = await callGeminiAPI(userQuery, false, systemPrompt); // Adaptar call
                const newQuestions = resultText.split('\n').filter(q => q.trim().length > 0);
                
                newQuestions.forEach(q => {
                    const questionHTML = createQuestionItemHTML(q, unitName, topicName);
                    container.insertAdjacentHTML('beforeend', questionHTML);
                });
                
                if (typeof lucide !== 'undefined') { lucide.createIcons(); }

            } catch (error) {
                console.error("Error generando más preguntas:", error);
                container.innerHTML += '<p class="text-red-500 text-sm">Error al generar preguntas.</p>';
            } finally {
                button.disabled = false;
                loader.style.display = 'none';
            }
        }

        /**
         * Helper para crear el HTML de un item de pregunta (para Modo Estudio) (de V6)
         */
        function createQuestionItemHTML(question, unitName, topicName) {
            // Este HTML es una réplica del usado en 'renderExamUI' de V6
            return `
                <div class="question-item py-4">
                    <p class="question-text">${question}</p>
                    <button class="answer-btn mt-3 px-4 py-1.5 bg-blue-500 text-white text-sm font-medium rounded-md hover:bg-blue-600 transition-colors inline-flex items-center" data-question="${question}">
                        <svg data-lucide="volume-2" class="w-4 h-4 mr-2"></svg>
                        Responder y Escuchar
                        <div class="answer-loader" style="display: none;"></div>
                    </button>
                    <button class="save-btn mt-3 ml-2 px-4 py-1.5 bg-green-500 text-white text-sm font-medium rounded-md hover:bg-green-600 transition-colors inline-flex items-center" data-question="${question}" data-topic="${topicName}" data-unit="${unitName}" style="display: none;">
                        <svg data-lucide="save" class="w-4 h-4 mr-2"></svg>
                        Guardar
                    </button>
                    <div class="answer-text" contenteditable="false" style="display: none;"></div>
                    <div class="audio-player-container"></div>
                </div>
            `;
        }

        /**
         * Manejador de clic de "Responder y Escuchar" (Unificado) (de V6)
         */
        async function handleAnswerClick(button) {
            const question = button.dataset.question;
            const container = button.closest('.question-item');
            if (!container) return; // Seguridad
            
            const loader = button.querySelector('.answer-loader');
            const answerTextEl = container.querySelector('.answer-text');
            const audioPlayerContainer = container.querySelector('.audio-player-container');
            const saveButton = container.querySelector('.save-btn'); 

            button.disabled = true;
            if (loader) loader.style.display = 'inline-block';
            if (answerTextEl) {
                answerTextEl.style.display = 'none';
                answerTextEl.innerHTML = 'Generando respuesta...';
            }
            if (audioPlayerContainer) audioPlayerContainer.innerHTML = '';
            if (saveButton) saveButton.style.display = 'none'; 

            try {
                const materials = {
                    syllabus: document.getElementById('syllabus').value,
                    theory: document.getElementById('theory').value,
                    experiences: document.getElementById('experiences').value
                };
                
                if (answerTextEl) answerTextEl.style.display = 'block';
                const answerText = await getAnswerForQuestion(question, materials);
                
                if (answerTextEl) {
                    answerTextEl.innerHTML = convertMarkdownToHTML(answerText);
                    answerTextEl.contentEditable = true;
                    answerTextEl.innerHTML += "\n\nGenerando audio...";
                }

                // Quitar Markdown/HTML para el audio
                const cleanAnswerForTTS = answerText.replace(/\*\*(.*?)\*\*/g, '$1'); 
                const { audioData, mimeType } = await callGeminiTTS(cleanAnswerForTTS);
                
                if (answerTextEl) answerTextEl.innerHTML = convertMarkdownToHTML(answerText); // Restaurar texto limpio con HTML
                if (audioPlayerContainer) await playAudio(audioData, mimeType, audioPlayerContainer);

                if (saveButton) {
                    saveButton.style.display = 'inline-flex'; 
                    saveButton.disabled = false;
                    // El icono de V6 era 'save' (lucide)
                    saveButton.innerHTML = `<svg data-lucide="save" class="w-4 h-4 mr-2"></svg>Guardar`;
                    if (typeof lucide !== 'undefined') lucide.createIcons();
                }

            } catch (error) {
                console.error("Error en handleAnswerClick:", error);
                if (answerTextEl) {
                    answerTextEl.innerHTML = `Error: ${error.message}`; 
                    answerTextEl.style.display = 'block';
                }
            } finally {
                button.disabled = false;
                if (loader) loader.style.display = 'none';
            }
        }

        /**
         * Manejador de clic de "Guardar" (Unificado) (de V6)
         */
        async function handleSaveClick(button) {
            const topic = button.dataset.topic;
            const question = button.dataset.question;
            const unit = button.dataset.unit;
            
            const container = button.closest('.question-item');
            if (!container) return;
            
            const answerTextEl = container.querySelector('.answer-text');
            const answer = answerTextEl.innerHTML; // Ya está en HTML (con <b>)

            if (!currentSubject) {
                showError("Por favor, selecciona una materia antes de guardar.");
                return;
            }

            if (!topic || !question || !answer || !unit) {
                showError("Error: no se pudo obtener la información para guardar (faltan datos).");
                return;
            }

            button.disabled = true;
            button.innerHTML = "Guardando...";

            try {
                // V15 usa 'saved_questions' para las tarjetas Anki. Usaré esa.
                const savedQuestionsRef = collection(db, 'artifacts', firebaseConfig.projectId, 'users', userId, 'subjects', currentSubject, 'saved_questions');
                
                await addDoc(savedQuestionsRef, {
                    unit: unit, 
                    topic: topic,
                    question: question,
                    answer: answer, // Se guarda la respuesta HTML
                    createdAt: serverTimestamp(),
                    reviewStep: 0,
                    nextReviewDate: serverTimestamp() // Vence "ahora" para estar en "Repasar"
                });

                button.innerHTML = "¡Guardado!";
                if (answerTextEl) answerTextEl.contentEditable = false; // Bloquear edición
                
                // Recargar pestañas relevantes
                if (currentTab === 'review') loadReviewData(currentSubject);
                if (currentTab === 'topics') loadTopicManager();
                if (currentTab === 'roadmap') loadRoadmapData(currentSubject);

            } catch (error) {
                console.error("Error al guardar Q&A:", error);
                showError(`No se pudo guardar la pregunta: ${error.message}`);
                button.disabled = false;
                button.innerHTML = "Reintentar Guardar";
            }
        }

        /**
         * Helper para obtener respuesta de IA (de V6)
         */
        async function getAnswerForQuestion(question, materials) {
            const systemPrompt = "Eres un profesor experto. Responde la siguiente pregunta de examen de forma concisa y directa, basándote en el material de estudio proporcionado. La respuesta debe ser ideal para un examen oral. IMPORTANTE: Para resaltar texto clave, usa el formato Markdown `**texto en negrita**`. No utilices ningún otro formato.";
            const userQuery = `
                Material de Estudio (Contexto):
                --- PLAN DE ESTUDIO ---
                ${materials.syllabus || "No proporcionado."}
                --- TEORÍA Y CASOS CLÍNICOS ---
                ${materials.theory || "No proporcionado."}
                --- EXPERIENCIAS PASADAS ---
                ${materials.experiences || "No proporcionado."}
                --- FIN DEL MATERIAL ---

                Pregunta a responder:
                "${question}"

                Por favor, genera una respuesta clara y concisa para esta pregunta.
            `;
            try {
                // Usar la nueva firma de callGeminiAPI
                const answer = await callGeminiAPI(userQuery, false, systemPrompt);
                return answer;
            } catch (error) {
                console.error("Error en getAnswerForQuestion:", error);
                throw error; // Re-lanzar el error para que handleAnswerClick lo atrape
            }
        }

        /**
         * Helper para convertir Markdown (de V6)
         */
        function convertMarkdownToHTML(text) {
            if (!text) return "";
            // Negrita: **texto** -> <b>texto</b>
            let html = text.replace(/\*\*(.*?)\*\*/g, '<b>$1</b>');
            // Quitar saltos de línea al inicio/fin (común en IA)
            html = html.trim();
            // Reemplazar saltos de línea con <br>
            html = html.replace(/\n/g, '<br>');
            return html;
        }

        // --- INICIO: Funciones TTS (traídas de V6) ---

        async function callGeminiTTS(textToSpeak) {
            // const apiKey = "AIzaSyA1RYWX9v5UFVVGVcI9KKyPXK3BDnIRkqw"; // Ya está definida globalmente
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${API_KEY}`;

            const payload = {
                contents: [{
                    parts: [{ text: `Di con tono claro e informativo: ${textToSpeak}` }]
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: "Kore" } 
                        }
                    }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorBody = await response.text();
                    throw new Error(`Error en API TTS (${response.status}): ${errorBody}`);
                }

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/")) {
                    return { audioData, mimeType };
                } else {
                    throw new Error("Respuesta de audio TTS inválida o no encontrada.");
                }
            } catch (error) {
                console.error("Error en callGeminiTTS:", error);
                throw error;
            }
        }
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        function pcmToWav(pcmData, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.byteLength);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.byteLength, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.byteLength, true);
            const pcm16 = new Int16Array(pcmData);
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(44 + i * 2, pcm16[i], true);
            }
            return new Blob([view], { type: 'audio/wav' });
        }
        async function playAudio(audioData, mimeType, playerContainer) {
            try {
                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                const audioUrl = URL.createObjectURL(wavBlob);
                playerContainer.innerHTML = '';
                const audio = document.createElement('audio');
                audio.src = audioUrl;
                audio.controls = true;
                playerContainer.appendChild(audio);
                audio.play();
            } catch (error) {
                console.error("Error al reproducir audio:", error);
                playerContainer.textContent = "Error al procesar audio.";
            }
        }

        // --- FIN: Funciones TTS (traídas de V6) ---

        // --- FIN: Lógica de Modo Estudio (traída de V6) ---


        function resetModes() {
            els.studyContainer.classList.add('hidden');
            els.examContainer.classList.add('hidden');
            els.modeSelection.classList.remove('hidden');
            els.syllabusBrowser.innerHTML = '<p class="text-gray-400">Cargando...</p>';
            // --- INICIO: Corrección ---
            // Limpiar la guía de estudio al volver
            document.getElementById('study-output').innerHTML = '';
            // Mostrar el selector de temas de nuevo
            els.syllabusBrowser.style.display = 'block';
            // --- FIN: Corrección ---
        }
        
        async function generateOralExam() {
            const out = document.getElementById('exam-output');
            out.innerHTML = "Generando...";
            const prompt = `Genera 3 preguntas de examen oral sobre: ${document.getElementById('syllabus').value.substring(0,1000)}...`;
            const res = await callGeminiAPI(prompt, false);
            out.innerHTML = `<div class="p-4 bg-white border rounded">${res.replace(/\n/g, '<br>')}</div>`;
        }
        // --- INICIO: NUEVA FUNCIÓN PARA MODO ENFOCADO ---
        function toggleFocusMode() {
            const sidebar = document.getElementById('choice-sidebar-col');
            const mainContent = document.getElementById('choice-main-col');
            const button = document.getElementById('toggle-sidebar-btn');
            
            if (!sidebar || !mainContent || !button) return;

            const isHidden = sidebar.classList.contains('hidden');
            
            if (isHidden) {
                // Mostrar Sidebar
                sidebar.classList.remove('hidden');
                mainContent.classList.remove('lg:col-span-3');
                mainContent.classList.add('lg:col-span-2');
                button.innerHTML = `<svg data-lucide="panel-left-close" class="w-5 h-5"></svg>`;
                button.title = "Ocultar panel";
            } else {
                // Ocultar Sidebar
                sidebar.classList.add('hidden');
                mainContent.classList.remove('lg:col-span-2');
                mainContent.classList.add('lg:col-span-3');
                button.innerHTML = `<svg data-lucide="panel-right-close" class="w-5 h-5"></svg>`;
                button.title = "Mostrar panel";
            }
            
            // Re-renderizar el ícono
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }
        // --- FIN: NUEVA FUNCIÓN PARA MODO ENFOCADO ---
        // --- UTILS ---
        const API_KEY = "AIzaSyA1RYWX9v5UFVVGVcI9KKyPXK3BDnIRkqw";

        // async function callGeminiAPI(prompt, expectJson) { // --- ESTA ES LA FUNCIÓN V15 INCORRECTA
        //     const url = `https...`;
        //     ...
        // }
        
        // --- INICIO: Reemplazo de callGeminiAPI con la versión de V6 ---
        async function callGeminiAPI(userQuery, expectJson, systemPrompt = null, generationConfig = null) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${API_KEY}`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
            };

            if (systemPrompt) {
                payload.systemInstruction = {
                    parts: [{ text: systemPrompt }]
                };
            }
            
            let finalGenConfig = generationConfig || {};
            if (expectJson && !finalGenConfig.responseMimeType) {
                 finalGenConfig.responseMimeType = "application/json";
            }
            
            if (Object.keys(finalGenConfig).length > 0) {
                payload.generationConfig = finalGenConfig;
            }

            let retries = 3;
            while (retries > 0) {
                try {
                    const resp = await fetch(url, { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify(payload) });
                    if (!resp.ok) {
                        const errorBody = await resp.text();
                        console.error("Error API:", errorBody);
                        throw new Error(`Error de API: ${resp.status}`);
                    }
                    const json = await resp.json();
                    if (!json.candidates || !json.candidates[0].content) {
                         console.warn("Respuesta inválida:", json);
                         throw new Error("Respuesta de IA inválida (sin 'candidates')");
                    }
                    return json.candidates[0].content.parts[0].text;
                } catch (error) {
                    console.error("Error en callGeminiAPI (intento restante " + (retries-1) + "):", error);
                    retries--;
                    if (retries === 0) throw error;
                    await new Promise(res => setTimeout(res, 1000)); // Backoff
                }
            }
        }
        // --- FIN: Reemplazo de callGeminiAPI ---

        function showError(msg, isError = true) {
            const m = document.getElementById('error-modal');
            const t = document.getElementById('error-msg');
            const h = document.getElementById('error-title');
            t.textContent = msg;
            h.textContent = isError ? "Error" : "Éxito";
            h.className = isError ? "text-red-600 font-bold text-lg mb-2" : "text-green-600 font-bold text-lg mb-2";
            m.style.display = 'flex';
        }

        // --- RUN ---
        init();
    </script>
</body>
</html>
